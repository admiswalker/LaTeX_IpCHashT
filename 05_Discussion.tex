\chapter{考察}
\label{chap_Discussion}

最大 load factor，メモリ使用量，挿入速度，探査速度，削除速度について考察する．
\leavevmode \newline

%
{\bf 最大 load factor}
\samepage\newline\indent
最大 load factor とテーブルサイズの関係，図\ref{fig_bench_LF}について考察する．
{\bf std::unordered\_map} はテーブルサイズ $10^2$ 未満で Load factor が低いものの，
区間 $10^2〜10^8$ において，高い Load factor を示している．
{\bf sstd::CHashT} は区間 $10^1〜10^8$ に渡り 72.5 \% 以上を維持している．
{\bf sstd::IpCHashT (as maxLF50)}，{\bf google::dense\_hash\_map}，{\bf ska::flat\_hash\_map} は，
Load factor が制限されており，50 \% に留まっている．
{\bf sstd::IpCHashT (as uint8 and maxLF100)} は，テーブルサイズ $10^3$ 未満では 90 \% 以上の Load factor を示す．
テーブルサイズが $10^3$ を超えるにしたがい，linked list の長さが uint8 の最大値 - 1 に制限されている影響により，
Load factor が単調に減少していく．
{\bf sstd::IpCHashT (as uint16 and maxLF100)} は区間 $10^1〜10^8$ に渡り 97.5 \% 以上を維持している．
なお，実際には 100 サンプルの中央値のため，
特に sstd::CHashT と sstd::IpCHashT (as uint8 and maxLF100) では，
特にテーブルサイズが $10^3$ 未満の場合において，ある程度揺らぎがある．
また，sstd::IpCHashT の実装はいずれもは，パディングされる配列長も Load factor の計算に加算される．
このため，{\bf sstd::IpCHashT (as maxLF50)} では端数が発生し，丁度に 50 \% とはならない．
\leavevmode \newline

%
{\bf メモリ使用量}
\samepage\newline\indent
メモリ使用量とテーブルサイズの関係，図\ref{fig_bench_memory}について考察する．
複数のピークはハッシュテーブルのリハッシュを示す．
ピークの持つ幅は測定間隔に等しく，実際には要素１つ分の幅しか持たない．
{\bf std::unordered\_map} は要素数にしたがって，ほぼ線形にメモリ使用量を増加させている．
これは，std::unordered\_map が要素ごとにメモリを確保することを示す．
また，リハッシュ時のピークも小さいことから，
アルゴリズムは ``Separate chaining with linked lists'' であると推察される．
{\bf sstd::IpCHashT (as uint16 and maxLF100)} は
広い区間において最も高いメモリ効率を示しており，
図\ref{fig_bench_LF}で示した load factor の高さを反映する結果となった．
一部，他のハッシュテーブルとは異なるタイミングでリハッシュが発生しており，
load factor が 100 \% まで達していないことを示している．
{\bf google::dense\_hash\_map} は
Load factor が 50 \% に削減されているにも関わらず，
std::unordered\_map 前後のメモリ使用量を示しており，
key の一部を空符号や削除符号として使用する実装の特性が現れている．
{\bf sstd::CHashT}，{\bf sstd::IpCHashT (as maxLF50)}，{\bf ska::flat\_hash\_map} は，
いずれもほぼ同じメモリ使用量を示している．
図\ref{fig_bench_LF}より，
{\bf sstd::CHashT} は区間 $10^1〜10^8$ に渡り 72.5 \% 以上を維持しているものの，
ポインタによる singly linked list の構築に 1 要素あたり 8 Byte\footnote{64 bits CPU のため．} 必要としており，
多くのメモリを消費する結果となった．
Load factor の高い区間において，
線形にメモリ使用量が伸びており，
衝突した要素分のメモリを動的に確保している．


\noindent
{\bf sstd::IpCHashT (as maxLF50)}，{\bf ska::flat\_hash\_map} は
検索速度を得るため，単位要素あたり最も多くのメモリを消費しており，
std::unordered\_map と比較して 1.5 倍程度となる．
実利用に際しては，このメモリ使用量を許容できるかどうかが，
一つの課題となる．
{\bf sstd::IpCHashT (as uint8 maxLF100)} は
sstd::IpCHashT (as maxLF50) と sstd::IpCHashT (as uint16 maxLF100) の
およそ中間でリハッシュする挙動を示している．
\leavevmode \newline

%
{\bf 挿入速度}
\samepage\newline\indent
挿入速度とテーブルサイズの関係，図\ref{fig_bench_insert_preAlloc}，\ref{fig_bench_insert_wRehash}，\ref{fig_bench_insert}について考察する．

テーブルのメモリを事前に確保した場合の挿入速度の累積時間は，
図\ref{fig_bench_insert_preAlloc} の通りである．
ただし，図\ref{fig_bench_insert} のように，挿入速度はテーブルサイズに依存しており，
ここでは，$2.0\times10^8$ に初期化されたテーブルに対する速度を示す．
まず，{\bf sstd::IpCHashT (as maxLF50)} と {\bf ska::flat\_hash\_map} は load factor が 50 \% を超えた時点でリハッシュしている．
{\bf google::dense\_hash\_map} についても，同じタイミングで load factor が 50 \% を超えているはずであるが，
事前にテーブルサイズを指定した場合には，リハッシュしないように制御されている様子が伺える．
{\bf sstd::IpCHashT (as uint8 and maxLF100)} については，
uint8 型により構成された singly linked list の最大範囲を超えた時点でリハッシュが発生している．
{\bf std::unordered\_map} は他のハッシュテーブルより 2\textasciitilde 3.5 倍程度遅い結果となった．
std::unordered\_map 以外のハッシュテーブルについて，計算量の違いは軽微である．

テーブルサイズを 0 で初期化した場合の挿入速度の累積時間は，
図\ref{fig_bench_insert_wRehash} の通りである．
図\ref{fig_bench_insert_preAlloc} と比較して，
{\bf sstd::CHashT} と {\bf sstd::IpCHashT (as uint16)} の累積時間の増加が顕著である．
これは，sstd::CHashT については，リハッシュそのものに時間が掛かっているためであり，
sstd::IpCHashT (as uint16) については，load factor の増加に伴い，空き要素の線形探査に時間が掛かるためである．
なお，他の条件の sstd::IpCHashT は，比較的 load factor の低い領域を使用するため，影響は軽微である．
{\bf std::unordered\_map} は，挿入とリハッシュの両方に時間が掛かっていることが伺える．
{\bf sstd::IpCHashT (as maxLF50)}，{\bf sstd::IpCHashT (as uint8 and maxLF100)}，{\bf ska::flat\_hash\_map}，{\bf google::dense\_hash\_map} に
ついては，計算量の違いは軽微である．

テーブルサイズと挿入速度の関係は，図\ref{fig_bench_insert} に示した通りである．
キャッシュの変わり目を除き，広い区間で {\bf ska::flat\_hash\_map} が高い性能を示している．
{\bf google::dense\_hash\_map} は，L2 キャッシュに乗る区間 $10^2〜 10^5$ では，ska::flat\_hash\_map に次ぐ速度を示すものの，
L3 キャッシュ外となる区間 $10^6〜 10^8$ では，sstd::IpCHashT (as maxLF50) と入れ替わる結果となった．
{\bf sstd::IpCHashT (as maxLF50)} は，その挿入アルゴリズムの複雑さの割に高速な挿入である．
これは，結局のところ，挿入操作が単なる線形探査であるためである．
しかしながら，{\bf sstd::IpCHashT (as uint8 and maxLF100)} と {\bf sstd::IpCHashT (as uint16)} の示す通り，
load factor の高い領域において，線形探査は大きく効率を落としている．
{\bf sstd::CHashT} は L2，L3 キャッシュの外へ格納が増えるにしたがい，大きく速度を落としている．
\leavevmode \newline

%
{\bf 探査速度}
\samepage\newline\indent
探査速度とテーブルサイズの関係，図
\ref{fig_bench_find_s_sm}，\ref{fig_bench_find_us_sm}，
\ref{fig_bench_find_s_um}，\ref{fig_bench_find_us_um}について考察する．

%%%
まず，Successful lookup の速度，図\ref{fig_bench_find_s_sm}，\ref{fig_bench_find_us_sm}について考察する．

Successful major option の図\ref{fig_bench_find_s_sm}について．
{\bf sstd::IpCHashT (as uint8 and maxLF50)} は，
L2 キャッシュから溢れるテーブルサイズ $10^5$ 前後を除き，
区間 $10^2〜10^7$ の殆どに渡り最速で探査している．
{\bf sstd::IpCHashT (as uint16)} は図\ref{fig_bench_memory} に示すように
google::dense\_hash\_map の 75 \% のメモリ使用量であるにも関わらず，
L3 キャッシュ内から CPU キャッシュ外の区間 $1.5\times10^5〜3.5\times10^7$ において，
同程度の速度を保持している．
ただし，区間 $1.0\times10^1〜1.5\times10^5$ と $3.5\times10^7〜2.0\times10^8$ においては，
google::dense\_hash\_map の方が高速に動作している．

Unsuccessful major option の図\ref{fig_bench_find_us_sm}について．
{\bf sstd::IpCHashT (as uint8 and maxLF50)} は，
L2 キャッシュから溢れるテーブルサイズ $10^5$ 前後を除き，
区間 $10^2〜10^7$ の殆どに渡り 1\textasciitilde 2 番目の探査速度を保持している．
一方で，その他のオプションの sstd::IpCHashT は，優位性のある速度に達していない．

%%%
次に，Unuccessful lookup の速度，図\ref{fig_bench_find_s_um}，\ref{fig_bench_find_us_um}について考察する．

Successful major option の図\ref{fig_bench_find_s_um}について．
{\bf sstd::IpCHashT (as uint8 and maxLF50)} は，
区間 $1.0\times10^2〜1.5\times10^5$ において，高速に動作するが，
区間 $1.5\times10^5〜1.5\times10^7$ においては，{\bf ska::flat\_hash\_map} が長い区間において，最速を保持している．
区間 $1.5\times10^7〜2.0\times10^8$ においては，よりメモリ効率の高い
{\bf sstd::IpCHashT (as uint8 and maxLF100)} や {\bf sstd::IpCHashT (as uint16)} が最速を保持している．
なお，図\ref{fig_taocp_v3_fig44} (a) に示すように，Separate Chaining は，本質的に Unsuccessful lookup に強く，
一部区間では，{\bf sstd::CHashT} であっても，google::dense\_hash\_map を上回る速度を示している．

Unsuccessful major option の図\ref{fig_bench_find_us_um}について．
{\bf sstd::IpCHashT (as uint8 and maxLF50)} は，
特に L1, L2 キャッシュに収まる区間 $1.0\times10^2〜1.5\times10^5$ では，
google::dense\_hash\_map の \textasciitilde4 倍程度高速に動作している．
また，
区間 $1.5\times10^5〜1.5\times10^7$ でも \textasciitilde3 倍程度高速に動作している．
一方で，
区間 $1.5\times10^7〜2.0\times10^8$ においては，よりメモリ効率の高い {\bf sstd::IpCHashT (as uint16)} が速度を伸ばした．
図\ref{fig_bench_find_us_um}の結果は特に，Chaining 系のアルゴリズムが高速に動作する結果となった．
\leavevmode \newline

%
{\bf 削除速度}
\samepage\newline\indent
削除速度とテーブルサイズの関係，図\ref{fig_bench_erase_sm}，\ref{fig_bench_erase_um} について考察する．

まず，Successful lookup を優先した設定と，
Unsuccessful lookup を優先した設定の違いについて考察する．
このベンチマークでは，存在する key-value ペアを削除しているため，
図\ref{fig_bench_erase_sm}に示す Successful lookup を優先する設定が，
図\ref{fig_bench_erase_um}に示す Unsuccessful lookup を優先する設定より高速に処理すると期待されたが，
明白な違いは認められなかった．

{\bf google::dense\_hash\_map} は，
区間 $1.0\times10^1〜2.0\times10^8$ のほぼ全てにおいて最速を保持している．
{\bf sstd::IpCHashT (as uint8 and maxLF50)} は，
L2 キャッシュ内の区間 $2.0\times10^2〜1.5\times10^5$ において，
ska::flat\_hash\_map より高速に動作するものの，
区間 $1.5\times10^2〜2.0\times10^8$ においては，
{\bf ska::flat\_hash\_map} の方が高速に動作している．
%\leavevmode \newline


