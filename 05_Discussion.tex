\chapter{考察}
\label{chap_Discussion}

考察について記述する．
\leavevmode \newline

%
{\bf Loadfactor}
\samepage\newline\indent
Load factor とテーブルサイズの関係は，図\ref{fig_bench_LF}に示す通りである．

{\bf std::unordered\_map} はテーブルサイズ $10^2$ 未満で Load factor が低いものの，
区間 $10^2〜10^8$ において，高い Load factor を示している．

{\bf sstd::CHashT} は区間 $10^1〜10^8$ に渡り 72.5 \% 以上を維持している．

{\bf sstd::IpCHashT (as maxLF50)}，{\bf google::dense\_hash\_map}，{\bf ska::flat\_hash\_map} は，
Load factor が制限されており，50 \% に留まっている．

{\bf sstd::IpCHashT (as uint8 and maxLF100)} は，テーブルサイズ $10^3$ 未満では 90 \% 以上の Load factor を示す．
テーブルサイズが $10^3$ を超えるにしたがい，linked list の長さが uint8 の最大値 - 1 に制限されている影響により，
Load factor が単調に減少していく．

{\bf sstd::IpCHashT (as uint16 and maxLF100)} は区間 $10^1〜10^8$ に渡り 97.5 \% 以上を維持している．

なお，実際には 100 サンプルの中央値のため，
特に sstd::CHashT と sstd::IpCHashT (as uint8 and maxLF100) では，
特にテーブルサイズが $10^3$ 未満の場合において，ある程度揺らぎがある．
また，sstd::IpCHashT の実装はいずれもは，パディングされる配列長も Load factor の計算に加算される．
このため，{\bf sstd::IpCHashT (as maxLF50)} では端数が発生し，丁度に 50 \% とはならない．
\leavevmode \newline

%
{\bf メモリ使用量}
\samepage\newline\indent
メモリ使用量とテーブルサイズの関係は，図\ref{fig_bench_memory}に示す通りである．
複数のピークはハッシュテーブルのリハッシュを示す．
ピークの持つ幅は測定間隔に等しく，実際には要素１つ分の幅しか持たない．

{\bf std::unordered\_map} は要素数にしたがって，ほぼ線形にメモリ使用量を増加させている．
これは，std::unordered\_map が要素ごとにメモリを確保することを示す．
また，リハッシュ時のピークも小さいことから，
アルゴリズムは ``Separate chaining with linked lists'' であると推察される．

{\bf sstd::IpCHashT (as uint16 maxLF100)} は
広い区間において最も高いメモリ効率を示しており，
図\ref{fig_bench_LF}で示した load factor の高さを反映する結果となった．
一部，他のハッシュテーブルとは異なるタイミングでリハッシュが発生しており，
load factor が 100 \% まで達していないことを示している．

{\bf google::dense\_hash\_map} は
Load factor が 50 \% に削減されているにも関わらず，
std::unordered\_map 前後のメモリ使用量を示しており，
key の一部を空符号や削除符号として使用する実装の特性が現れている．

{\bf sstd::CHashT}，{\bf sstd::IpCHashT (as maxLF50)}，{\bf ska::flat\_hash\_map} は，
いずれもほぼ同じメモリ使用量を示している．
図\ref{fig_bench_LF}より，

{\bf sstd::CHashT} は区間 $10^1〜10^8$ に渡り 72.5 \% 以上を維持しているものの，
ポインタによる singly linked list の構築に 1 要素あたり 8 Byte\footnote{64 bits CPU のため．} 必要としており，
多くのメモリを消費する結果となった．
Load factor の高い区間において，
線形にメモリ使用量が伸びており，
衝突した要素分のメモリを動的に確保している．

{\bf sstd::IpCHashT (as maxLF50)}，{\bf ska::flat\_hash\_map} は
検索速度を得るため，単位要素あたり最も多くのメモリを消費しており，
std::unordered\_map と比較して 1.5 倍程度となる．
実利用に際しては，このメモリ使用量を許容できるかどうかが，
一つの課題となる．

{\bf sstd::IpCHashT (as uint8 maxLF100)} は
sstd::IpCHashT (as maxLF50) と sstd::IpCHashT (as uint16 maxLF100) の
およそ中間でリハッシュする挙動を示している．
\leavevmode \newline

%
{\bf 挿入}
\samepage\newline\indent
%挿入速度とテーブルサイズの関係を，図
%\ref{fig_bench_insert_preAlloc_sm}，\ref{fig_bench_insert_wRehash_sm}に示す．
%挿入処理において，Hard insertion では find() 関数を用いるが，Soft insertion では，find() 関数を用いない．
%本ベンチマークでは，Soft insertion を用いる．
%したがって，Successful lookup と Unuccessful lookup オプションによる違いはない．
\leavevmode \newline

%
{\bf 探査}
\samepage\newline\indent
%探査速度とテーブルサイズの関係を，図
%\ref{fig_bench_find_s_sm}，\ref{fig_bench_find_us_sm}，
%\ref{fig_bench_find_s_um}，\ref{fig_bench_find_us_um}に示す．
%図\ref{fig_bench_find_s_sm}，\ref{fig_bench_find_us_sm}は Successful lookup を優先した設定，
%図\ref{fig_bench_find_s_um}，\ref{fig_bench_find_us_um}は Unsuccessful lookup を優先した設定である．
\leavevmode \newline

%
{\bf 削除}
\samepage\newline\indent
まず，Successful lookup を優先した設定と，
Unsuccessful lookup の違いについて考察する．
本ベンチマークでは存在する key-value ペアを削除しているため，
図\ref{fig_bench_erase_sm}に示す Successful lookup を優先する設定が，
図\ref{fig_bench_erase_um}に示す Unsuccessful lookup を優先する設定より高速に処理すると期待されたが，
明白な違いは認められなかった．
%削除速度とテーブルサイズの関係を，図
%\ref{fig_bench_erase_sm}，
%\ref{fig_bench_erase_um}に示す．
%図\ref{fig_bench_erase_sm}は Successful lookup を優先した設定，
%図\ref{fig_bench_erase_um}は Unsuccessful lookup を優先した設定である．
\leavevmode \newline


