\chapter{アルゴリズム}
\label{chap_Algorism}

従来の Closed hashing では，
衝突ないし probing によりハッシュ値が使用中の場合，
本来１回目の探査でアクセスできるはずの key であっても，
probing により衝突を解決しなくてはならない．
そこで，要素挿入時に，要素位置を整理して挿入する手法を提案する．
これは．挿入時間を犠牲に search 速度を向上させることを意味する．
一般に，要素を先頭から末尾までただ辿る場合は，singly linked list を用いる．
今回は，後から挿入位置を整理するため，doubly linked list を用いる．

これらの提案は，本質的に \cite{ADMIS2017} で行った提案と同じものである．
以下，
図\ref{fig_IpCHashT_struct}，
図\ref{fig_IpCHashT_insert_hard_case01}〜\ref{fig_IpCHashT_insert_hard_case11}，
図\ref{fig_IpCHashT_deletion_case01}〜\ref{fig_IpCHashT_deletion_case06}は，
\cite{ADMIS2017} に由来する図である．
今回は，
新たに挿入操作に soft insertion を採用した．
検索操作においても，
Successful search を優先するオプションと，
Unsuccessful search を優先するオプションについてそれぞれ実装と評価を行う．
また，テーブルサイズによってパディングサイズを動的に変更することで，
テーブルサイズが小さい場合に load factor が低下する問題に対処する．
加えて，テンプレートを用いて実装するにあたり，
ソフトウェアをフルスクラッチで書き直した．
要素の挿入においては，操作手順を再検討し，より簡潔な実装とした．
品質は多数のテストコードにより担保した．

In-place hash table (以下，IpCHashT) では図\ref{fig_IpCHashT_struct}に示すデータ構造を備える．
各要素には key-value pair の他に，linked list のための prev 要素と next 要素を持つ．
T\_shift には unsigned int 型を用い，相対位置による linked list を構成する．
これは，ポインタ接続におけるメモリ消費量が無視できないためである．
\footnote{
  例えば 64 bits CPU の場合，ポインタサイズは 64 bits であるから，T\_key と T\_val が uint64 型の場合，
  テープルサイズの 50\% が doubly linked list に由来する．
}．

\begin{figure} % 特に強い理由がない限り、[htbp]のような指定はしないでください。
\begin{lstlisting}[language=C++]
template <class T_key, class T_val, typename T_shift>
struct element{
	element(){
		T_shift maxShift = (T_shift) 0; maxShift =~ maxShift;
		prev = maxShift;
		next = (T_shift) 0;
	}
	~element(){}
	
	T_key key;
	T_val val;
	T_shift prev;
	T_shift next;
};
\end{lstlisting}
\caption{
  IpCHashT 要素の C++ 擬似構造体．T\_key は key の型，T\_val は val の型である．
  T\_shift は doubly linked list に用いる型で，uint8 または uint16 を指定する．
  uint16 より大きな型を指定するメリットは殆どない．
  prev は 前の要素までの相対距離を，next は 次の要素までの相対距離を表す．
  ポインタにおけるアドレスとは異なり，区間 [0, max(T\_shift) - 1] の範囲でリンクを表現する．
  ただし，max(T\_shift) は T\_shift 型の取り得る最大値である．
  0 のときに自分自身を示し，max(T\_shift) - 1 がリンクできる最大距離である．区間外へのリンクはできない．
  max(T\_shift) は，予約されており，'prev==max(T\_shift)' のとき，要素が空であることを示す．
  また，'prev==0' であれば linked list の先頭であること，'next==0' であれば linked list の末尾であることが分かる．
}
\label{fig_IpCHashT_struct}
\end{figure}

\begin{figure}
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_01.pdf}
  \caption{
    図\ref{fig_IpCHashT_apparence}〜\ref{fig_IpCHashT_deletion_case06}に用いる記号．
    ``Ope.''は，実行順序を意味し，``Ope. 0'' は初期状態を表す．
    下向き矢印は，ハッシュ値の示す配列アドレス上に置かれる．
    各要素は，丸１つと prev locator １つ，next locator １つで構成されるが，
    接続が無い場合 locator は省略される．
    点線で書かれた丸は空の要素を表し，緑の枠線と矢印は要素の移動を表す．
    バツ印は linked list の削除を意味する．
    配色は，青色を初期状態，赤色を要素の挿入・削除動作，緑色を要素の移動，と分かれている．
  }
  \label{fig_IpCHashT_fig_description}
%\end{figure}

%\begin{figure}
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_03.pdf}
  \caption{
    IpCHashT に挿入された要素の抽象表現.
    この場合，3 つの要素のハッシュ値は，いずれも first 要素のアドレスを示すため，
    linked list により衝突を解決している．
    各要素は prev locator と next locator の示す相対位置により接続されており，
    各要素間に別の要素がある可能性がある．
  }
  \label{fig_IpCHashT_apparence}
%\end{figure}

%\begin{figure}
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_04.pdf}
  \caption{
    図\ref{fig_IpCHashT_apparence}に示す抽象表現を連続アドレス空間上に写像した一例.
    同じ抽象表現でも，挿入と削除の手順により格納状態は異なる．
    灰色の枠線が配列を表す．
    青字の linked list は図\ref{fig_IpCHashT_apparence}に示す抽象表現の写像であり，
    赤字の linked list は間に挿入された別の chain である．
    この例では，手前に空き要素があるにも関わらず，
    青字の linked list の末尾が不用意に遠い場所に格納されており，
    断片化している．
  }
  \label{fig_IpCHashT_insert_introspection}
\end{figure}

本章で示す図は，
青字を初期状態とし，赤字が挿入時の変更を，緑字は要素の移動に伴う変更を，それぞれ表す．
また，図\ref{fig_IpCHashT_apparence}〜\ref{fig_IpCHashT_deletion_case06}で用いる記号を
図\ref{fig_IpCHashT_fig_description}に示す．
図\ref{fig_IpCHashT_apparence}〜\ref{fig_IpCHashT_deletion_case06}では，
丸印ひとつ一つが配列要素を，
双方向に張られた２つの矢印が doubly linked list を表す．
Open hashing を用いたハッシュテーブルの説明では，
連続したアドレス空間上の配列要素が，
２辺を共有した四角形の連なりにより表現されることが多い．
同様に，IpCHashT では，配列要素を図\ref{fig_IpCHashT_apparence}のように抽象化して表すが，
一見すると隣接した連続構造であっても，
実際には，図\ref{fig_IpCHashT_insert_introspection}のように，
各要素が断続的なアドレス空間上に存在することがある．

%\leavevmode \newline
%\leavevmode \newline
%\vspace{-1cm}
\section{挿入}

高い検索性能を達成するためには，
命令数を削減するだけでなく，
キャッシュミスを抑える必要がある．
一般に，CPU は配列の連続アクセスに対して，
参照の局所性を利用してキャッシングする．
ここでは，
必要な要素を配列に隙間なく詰め込むことが，
空間的局所性と逐次的局所性を高め，
キャッシュミスを削減する．

通常の Chaining であれば，
新しく確保したメモリアドレスをポインタにより接続するため，
挿入済みの要素がメモリ上の何処に存在するかを考慮する必要はなく，
メモリの確保自体も malloc 関数に任せればよい．
しかし今回のように，
連続したメモリアドレス上に doubly linked list を構築するには，
メモリ自体を手動で管理する必要がある．

key-value pair を１つ挿入するには，
次の 1) 〜 4) の場合を考える．
1) key のハッシュ値が示す配列が空の場合は，図\ref{fig_IpCHashT_insert_hard_case01}のように単に要素を詰める．
2) 既に要素が挿入されており，chain の間に空きがある場合は，図\ref{fig_IpCHashT_insert_hard_case02}のように間に挿入する．
3) chain の間に空きがない場合は，図\ref{fig_IpCHashT_insert_hard_case03}のように末尾に空きを探し挿入する．
4) 挿入先の要素が異なるハッシュ値を持つ要素の退避先に使用されている場合は，
図\ref{fig_IpCHashT_insert_hard_case04}〜\ref{fig_IpCHashT_insert_hard_case11}のように挿入する．
要素の退避先と locator の再接続先との兼ね合いのため，4) には多くの場合分けが必要となる．

chain 間に空きがあるかを調べるには，線形探査を行う．
これには，対象の要素を全て調べ上げる必要があり，処理に時間が掛かる．
また，11 通りの場合分けを全て実装するには非常に手間も掛かる．
図\ref{fig_IpCHashT_insert_hard_case01}〜\ref{fig_IpCHashT_insert_hard_case11}に示す場合分けは，
任意の箇所に空きが合った場合を考慮している．
要素削除なく挿入する場合には，メモリの断片化は発生しないため，
必要な場合分けは
図\ref{fig_IpCHashT_insert_hard_case01}，
\ref{fig_IpCHashT_insert_hard_case03}，
\ref{fig_IpCHashT_insert_hard_case06}，
\ref{fig_IpCHashT_insert_hard_case11}
の５通りに限定される．
また，要素削除を伴う場合においても，挿入コストが大きくなるため，推奨しない．
これは，実装コストの低減および，挿入の高速化と引き換えに，
要素の削除と再挿入によるメモリ断片化への耐性を捨てることを意味する．

\section{探査}
挿入済みの要素を探査するには，図\ref{alg_find_sm}，\ref{alg_find_usm}に示すアルゴリズムが考えられる．
図\ref{alg_find_sm}は Successful search を優先した設定であり，
図\ref{alg_find_usm}は Unsuccessful search を優先した設定である．

\begin{figure}[h] % 特に強い理由がない限り、[htbp]のような指定はしないでください。
\begin{lstlisting}[language=C++]
template <class T_key, class T_val>
(bool, T_val) find(T_key key_in){
	uint64 hashVal = hashFunc( key_in );
	uint64 idx = hashVal & tableSize_minus1;
	
	if(! isHead( table[ idx ] ) ){ return ( false, none ); }
	for(;;){
		if( table[ idx ].key == key_in ){ return ( true, table[ idx ].val ); }
		if( table[ idx ].next == 0 ){ return ( false, none ); }
		idx += table[ idx ].next;
	}
}
\end{lstlisting}
\caption{
  Pseudo C++ code of find function prioritizing successful search.
  This function will search ``key\_in''.
  If key is found, the function will return ``true'' and corresponding value that is expressed as ``table[ idx ].val''.
  For prioritizing successful search, isHead() function will check the link list is head or not at first.
}
\label{alg_find_sm}
%\end{figure}
%\begin{figure}[h] % 特に強い理由がない限り、[htbp]のような指定はしないでください。
\begin{lstlisting}[language=C++]
template <class T_key, class T_val>
(bool, T_val) find(T_key key_in){
	uint64 hashVal = hashFunc( key_in );
	uint64 idx = hashVal & tableSize_minus1;
	
	for(;;){
		if( table[ idx ].key == key_in ){
			if( isEmpty( table[ idx ] ) ){ return ( false, none ); }
			return ( true, table[ idx ].val );
		}
		if( table[ idx ].next == 0 ){ return ( false, none ); }
		idx += table[ idx ].next;
	}
}
\end{lstlisting}
\caption{
  Pseudo C++ code of find function prioritizing unsuccessful search.
  This function will search ``key\_in''.
  If key is found, the function will return ``true'' and corresponding value that is expressed as ``table[ idx ].val''.
  For prioritizing unsuccessful search, isHead() function is removed compared to successful search prioritizing option.
}
\label{alg_find_usm}
\end{figure}

%\begin{algorithm}
%  \caption{Calculate $y = x^n$}
%  \label{alg1}
%  \begin{algorithmic}
%    \REQUIRE $n \geq 0 \vee x \neq 0$
%    \ENSURE $y = x^n$
%    \STATE $y \Leftarrow 1$
%    \IF{$n < 0$}
%    \STATE $X \Leftarrow 1 / x$
%    \STATE $N \Leftarrow -n$
%    \ELSE
%    \STATE $X \Leftarrow x$
%    \STATE $N \Leftarrow n$
%    \ENDIF
%    \WHILE{$N \neq 0$}
%    \IF{$N$ is even}
%    \STATE $X \Leftarrow X \times X$
%    \STATE $N \Leftarrow N / 2$
%    \ELSE[$N$ is odd]
%    \STATE $y \Leftarrow y \times X$
%    \STATE $N \Leftarrow N - 1$
%    \ENDIF
%    \ENDWHILE
%  \end{algorithmic}
%\end{algorithm}

\section{削除}

通常，linked list の要素を削除するには，要素を削除した上で，ポインタを繋ぎ変えればよい．
しかし，IpCHashT では，幾つかの場合を考慮する必要がある．

key-value pair を１つ削除するには，
次の 1) 〜 4) と，メモリの断片化を防ぐ処理として 5) を考える．
1) 単一要素の場合は，図\ref{fig_IpCHashT_insert_hard_case01}のように単に削除する．
2) 末尾要素を削除する場合は，図\ref{fig_IpCHashT_insert_hard_case02}のように要素と locator を削除する．
3) 先頭の要素が削除された場合，探査不能としないため，先頭に別の要素をつなぎ替える必要がある．
図\ref{fig_IpCHashT_insert_hard_case03}では，断片化を防ぐために，末尾のデータを先頭へ移動させている．
4) chain の中間要素を削除する場合は，図\ref{fig_IpCHashT_insert_hard_case04}のように末尾要素を移動させる．
5) 別の削除処理によって，末尾の要素が移動すると，
図\ref{fig_IpCHashT_insert_hard_case05}，\ref{fig_IpCHashT_insert_hard_case06}のように，
chain の要素間に空きができ，断片化する場合がある．これを
図\ref{fig_IpCHashT_insert_hard_case05}，\ref{fig_IpCHashT_insert_hard_case06}に示す操作を繰り返すことにより修正する．
ただし，空き要素の探査は線形探査する必要がある．
また，要素を移動させる度に別の chain に空きができる可能性があるため，再帰的に行う必要がある．
この処理は，実行コストが高いため推奨しない．

以上を勘案して，1) 〜 4) の操作を実装する．

% \section{断片化}
\section{配列の末尾処理}

要素の衝突が発生した際，Closed hashing では，
現在より後のアドレスに key-value pair を格納することで衝突を解決する．
しかし，ハッシュ値が配列の末尾を示した場合は，
退避先の配列要素が存在しない．
この場合，配列の末尾に達した場合は，
1) 引き続いて先頭から辿るように処理する，
2) 予め末尾に余分な配列を確保する，
の二択である．
まず，1) は，ハッシュテーブル探査時に，
探査アドレスの読み込みが不連続となる場合があり，
キャッシュミスを誘発する．このため採用できない．
続いて，2) は，キャッシュミスを誘発する危険はないものの，
余分な配列をどの程度確保するか問題となる．

2) の実装で最も簡単なのが，固定長のパディングである．
ただし，これには欠点があり，テーブルサイズが小さいとき，
パディングが不足すると衝突を解決できずにリハッシュが発生し，
load factor の上限は上がらない，
逆に，パディングサイズが過剰になると，
不用意にリハッシュが抑制され，探査効率が落ちる．

テーブルサイズが小さい場合，
パディングサイズが大きいいと，
テーブルサイズよりもパディングサイズが支配的となる．
逆に，テーブルサイズが大きい場合，
パディングサイズが小さいと，
退避先配列がなくなり，
load factor の上限が悪化する．
したがって，パディングサイズは，
テーブルサイズに比例するように調整する必要がある．

必要なパディングサイズは，
線形に増加すると推測されるため，

\[
  {\rm pSize} = \begin{cases}
    (1/a) \cdot {\rm tSize} & ({\rm tSize}<{\rm limit}) \\
    {\rm limit}    & ({\rm tSize}\geq{\rm limit})
  \end{cases}
\]
\[
  a: {\rm threshold}, \ \ 
  {\rm pSize}: {\rm padding \ size}, \ \ 
  {\rm tSize: table \ size}
\]

とすればよい．
しかし，
テーブルサイズが小さい場合，
単純に原点を通した調整では，
ハッシュ値の示すアドレスが十分に分散しないため，
load factor の上限値が安定しない．
したがって，先ほどの数式に，バイアス項を付与した

\[
  {\rm pSize} = \begin{cases}
    (1/a) \cdot {\rm tSize} + b & ({\rm tSize}<{\rm limit}) \\
    {\rm limit}    & ({\rm tSize}\geq{\rm limit})
  \end{cases}
\]
\[
  a: {\rm threshold}, \ \ 
  b: {\rm bias}, \ \ 
  {\rm pSize}: {\rm padding \ size}, \ \ 
  {\rm tSize}: {\rm table \ size}
\]

をパディングの調整に用いる．

\section{ハッシュ値の計算}

ハッシュテーブルでは，key からハッシュ値を生成し，テーブルサイズに収まるように丸める．
このとき，剰余演算を用いて丸めることが多い．
剰余演算を用いる場合には，ハッシュ値とテーブルサイズが互いに素となるよう素数にするのが望ましい \citep{石畑1989}．
しかしながら，
第\ref{chap_Introduction}章で先行研究の示すように，
整数除算は高速なハッシュテーブルに用いるにはあまりにも遅い．
したがって，
google::dense\_hash\_map と同様に，
テーブルサイズを 2 のべき乗とし，
bit mask 演算によりハッシュ値を丸める．


\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_06.pdf}
  \caption{ Insertion case01. }
  \label{fig_IpCHashT_insert_hard_case01}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_07.pdf}
  \caption{ Insertion case02. }
  \label{fig_IpCHashT_insert_hard_case02}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_08.pdf}
  \caption{ Insertion case03. }
  \label{fig_IpCHashT_insert_hard_case03}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_09.pdf}
  \caption{ Insertion case04. }
  \label{fig_IpCHashT_insert_hard_case04}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_10.pdf}
  \caption{ Insertion case05. }
  \label{fig_IpCHashT_insert_hard_case05}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_11.pdf}
  \caption{ Insertion case06. }
  \label{fig_IpCHashT_insert_hard_case06}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_12.pdf}
  \caption{ Insertion case07. }
  \label{fig_IpCHashT_insert_hard_case07}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_13.pdf}
  \caption{ Insertion case08. }
  \label{fig_IpCHashT_insert_hard_case08}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_14.pdf}
  \caption{ Insertion case09. }
  \label{fig_IpCHashT_insert_hard_case09}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_15.pdf}
  \caption{ Insertion case10. }
  \label{fig_IpCHashT_insert_hard_case10}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_16.pdf}
  \caption{ Insertion case11. }
  \label{fig_IpCHashT_insert_hard_case11}
\end{figure}

%---

\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_18.pdf}
  \caption{ Deletion case01. }
  \label{fig_IpCHashT_deletion_case01}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_19.pdf}
  \caption{ Deletion case02. }
  \label{fig_IpCHashT_deletion_case02}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_20.pdf}
  \caption{ Deletion case03. }
  \label{fig_IpCHashT_deletion_case03}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_21.pdf}
  \caption{ Deletion case04. }
  \label{fig_IpCHashT_deletion_case04}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_22.pdf}
  \caption{
    Deletion case05.
    削除時の断片化を低減する処理．
    空き要素を線形探査し，詰められるなくなるまで，再帰的に実行する必要があり，実行コストは非常に高い．
  }
  \label{fig_IpCHashT_deletion_case05}
%\end{figure}

%\begin{figure}[h]
  \includegraphics[scale=0.73]{./fig_algo/algorism_crop_23.pdf}
  \caption{
    Deletion case06.
    削除時の断片化を低減する処理．
    空き要素を線形探査し，詰められるなくなるまで，再帰的に実行する必要があり，実行コストは非常に高い．
  }
  \label{fig_IpCHashT_deletion_case06}
\end{figure}

%---

