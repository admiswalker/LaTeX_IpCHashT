\chapter{アルゴリズム}
\label{chap_Algorism}

従来の Closed hashing では，
衝突ないし probing によりハッシュ値が使用中の場合，
本来１回目の探査でアクセスできるはずの key であっても，
probing により衝突を解決しなくてはならない．
そこで，要素挿入時に，要素位置を整理して挿入する手法を提案する．
これは．挿入時間を犠牲に lookup 速度を向上させることを意味する．
一般に，要素を先頭から末尾までただ辿る場合は，singly linked list を用いる．
今回は，後から挿入位置を整理するため，doubly linked list を用いる．

In-place hash table (以下，IpCHashT) では図\ref{fig_IpCHashT_struct}に示すデータ構造を備える．
各要素には key-value pair の他に，linked list のための prev 要素と next 要素を持つ．
T\_shift には unsigned int 型を用い，相対位置による linked list を構成する．
これは，ポインタ接続におけるメモリ消費量が無視できないためである．
\footnote{
  例えば 64 bits CPU の場合，ポインタサイズは 64 bits であるから，T\_key と T\_val が uint64 型の場合，
  テープルサイズの 50\% が doubly linked list に由来する．
}．

\begin{figure} % 特に強い理由がない限り、[htbp]のような指定はしないでください。
\begin{lstlisting}[language=C++]
template <class T_key, class T_val, typename T_shift>
struct element{
	element(){
		T_shift maxShift = (T_shift) 0; maxShift =~ maxShift;
		prev = maxShift;
		next = (T_shift) 0;
	}
	~element(){}
	
	T_key key;
	T_val val;
	T_shift prev;
	T_shift next;
};
\end{lstlisting}
\caption{
  IpCHashT 要素の C++ 擬似構造体．T\_key は key の型，T\_val は val の型である．
  T\_shift は doubly linked list に用いる型で，uint8 または uint16 を指定する．
  uint16 より大きな型を指定するメリットは殆どない．
  prev は 前の要素までの相対距離を，next は 次の要素までの相対距離を表す．
  ポインタにおけるアドレスとは異なり，区間 [0, max(T\_shift) - 1] の範囲でリンクを表現する．
  ただし，max(T\_shift) は T\_shift 型の取り得る最大値である．
  0 のときに自分自身を示し，max(T\_shift) - 1 がリンクできる最大距離である．区間外へのリンクはできない．
  max(T\_shift) は，予約されており，'prev==max(T\_shift)' のとき，要素が空であることを示す．
  また，'prev==0' であれば linked list の先頭であること，'next==0' であれば linked list の末尾であることが分かる．
}
\label{fig_IpCHashT_struct}
\end{figure}

\begin{figure}
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_01.pdf}
  \caption{
    図\ref{fig_IpCHashT_apparence}〜\ref{fig_IpCHashT_deletion_case06}に用いる記号．
    ``Ope.''は，実行順序を意味し，``Ope. 0'' は初期状態を表す．
    下向き矢印は，ハッシュ値の示す配列アドレス上に置かれる．
    各要素は，丸１つと prev locator １つ，next locator １つで構成されるが，
    接続が無い場合 locator は省略される．
    点線で書かれた丸は空の要素を表し，緑の枠線と矢印は要素の移動を表す．
    バツ印は linked list の削除を意味する．
    配色は，青色を初期状態，赤色を要素の挿入・削除動作，緑色を要素の移動，と分かれている．
  }
  \label{fig_IpCHashT_fig_description}
\end{figure}

本章で示す図は，
青字を初期状態とし，赤字が挿入時の変更を，緑字は要素の移動に伴う変更を，それぞれ表す．
また，図\ref{fig_IpCHashT_apparence}〜\ref{fig_IpCHashT_deletion_case06}で用いる記号を
図\ref{fig_IpCHashT_fig_description}に示す．
図\ref{fig_IpCHashT_apparence}〜\ref{fig_IpCHashT_deletion_case06}では，
丸印ひとつ一つが配列要素を，
双方向に張られた２つの矢印が doubly linked list を表す．
Open hashing を用いたハッシュテーブルの説明では，
連続したアドレス空間上の配列要素が，
２辺を共有した四角形の連なりにより表現されることが多い．
同様に，IpCHashT では，配列要素を図\ref{fig_IpCHashT_apparence}のように抽象化して表すが，
一見すると隣接した連続構造であっても，
実際には，図\ref{fig_IpCHashT_insert_introspection}のように，
各要素が断続的なアドレス空間上に存在することがある．

\begin{figure}
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_03.pdf}
  \caption{
    IpCHashT に挿入された要素の抽象表現.
    この場合，3 つの要素のハッシュ値は，いずれも first 要素のアドレスを示すため，
    linked list により衝突を解決している．
    各要素は prev locator と next locator の示す相対位置により接続されており，
    各要素間に別の要素がある可能性がある．
  }
  \label{fig_IpCHashT_apparence}
\end{figure}

\begin{figure}
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_04.pdf}
  \caption{
    図\ref{fig_IpCHashT_apparence}に示す抽象表現を連続アドレス空間上に写像した一例.
    同じ抽象表現でも，挿入と削除の手順により格納状態は異なる．
    灰色の枠線が配列を表す．
    青字の linked list は図\ref{fig_IpCHashT_apparence}に示す抽象表現の写像であり，
    赤字の linked list は間に挿入された別の chain である．
    この例では，手前に空き要素があるにも関わらず，
    青字の linked list の末尾が不用意に遠い場所に格納されており，
    断片化している．
  }
  \label{fig_IpCHashT_insert_introspection}
\end{figure}

ハッシュテーブルの主要な動作は，挿入・探査・削除である．
IpCHashT における検索は，単に linked list を辿るだけであるから，
ここでは，挿入と削除について説明する．

%\leavevmode \newline
%\leavevmode \newline
%\vspace{-1cm}
\section{挿入}

高い検索性能を達成するためには，
命令数を削減するだけでなく，
キャッシュミスを抑える必要がある．
一般に，CPU は配列の連続アクセスに対して，
参照の局所性を利用してキャッシングする．
ここでは，
必要な要素を配列に隙間なく詰め込むことが，
空間的局所性と逐次的局所性を高め，
キャッシュミスを削減する．

通常の Chaining であれば，
新しく確保したメモリアドレスをポインタにより接続するため，
挿入済みの要素がメモリ上の何処に存在するかを考慮する必要はなく，
メモリの確保自体も malloc 関数に任せればよい．
しかし今回のように，
連続したメモリアドレス上に doubly linked list を構築するには，
メモリ自体を手動で管理する必要がある．

key-value pair を１つ挿入するとき，
1) key のハッシュ値が示すテーブルのアドレスが空の場合は，図\ref{fig_IpCHashT_insert_hard_case01}のように単に要素を詰める．
2) 既に要素が挿入されており，chain の間に空きがある場合は，図\ref{fig_IpCHashT_insert_hard_case02}のように間に挿入する．
3) chain の間に空きがない場合は，図\ref{fig_IpCHashT_insert_hard_case03}のように，末尾に空きを探し挿入する．
4) 挿入先の要素が異なるハッシュ値を持つ要素の退避先に使用されている場合は，
図\ref{fig_IpCHashT_insert_hard_case04}〜\ref{fig_IpCHashT_insert_hard_case11}のように挿入する．
これだけの場合分けが必要となるのは，要素の退避先と locator の再接続先との兼ね合いである．

chain 間に空きがあるかを調べるには，線形探査を行う．
これには，対象の要素に全て調べ上げる必要があり，処理に時間が掛かる．
また，11 通りの場合分けを全て実装するには非常に手間も掛かる．
ここで示す場合分けは，
任意の箇所に空きが合った場合を考慮しており，
ハッシュテーブルの内容を固定して利用する場合は，
要素削除なく挿入するため，メモリが断片化することはない．
これらを考慮すると，必ず実装しなくてはいけないのは，
図\ref{fig_IpCHashT_insert_hard_case01}，
\ref{fig_IpCHashT_insert_hard_case03}，
\ref{fig_IpCHashT_insert_hard_case06}，
\ref{fig_IpCHashT_insert_hard_case11}
の５通りである．
これは，挿入時の実行コストと引き換えに，
要素の削除と再挿入によるメモリ断片化への耐性を捨てることを意味する．

% \section{探査}

\section{削除}

\section{断片化}

\section{配列確保（パディングの話）}

%---

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_06.pdf}
  \caption{ Insertion case01. }
  \label{fig_IpCHashT_insert_hard_case01}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_07.pdf}
  \caption{ Insertion case02. }
  \label{fig_IpCHashT_insert_hard_case02}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_08.pdf}
  \caption{ Insertion case03. }
  \label{fig_IpCHashT_insert_hard_case03}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_09.pdf}
  \caption{ Insertion case04. }
  \label{fig_IpCHashT_insert_hard_case04}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_10.pdf}
  \caption{ Insertion case05. }
  \label{fig_IpCHashT_insert_hard_case05}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_11.pdf}
  \caption{ Insertion case06. }
  \label{fig_IpCHashT_insert_hard_case06}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_12.pdf}
  \caption{ Insertion case07. }
  \label{fig_IpCHashT_insert_hard_case07}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_13.pdf}
  \caption{ Insertion case08. }
  \label{fig_IpCHashT_insert_hard_case08}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_14.pdf}
  \caption{ Insertion case09. }
  \label{fig_IpCHashT_insert_hard_case09}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_15.pdf}
  \caption{ Insertion case10. }
  \label{fig_IpCHashT_insert_hard_case10}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_16.pdf}
  \caption{ Insertion case11. }
  \label{fig_IpCHashT_insert_hard_case11}
\end{figure}

%---

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_18.pdf}
  \caption{ Deletion case01. }
  \label{fig_IpCHashT_deletion_case01}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_19.pdf}
  \caption{ Deletion case02. }
  \label{fig_IpCHashT_deletion_case02}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_20.pdf}
  \caption{ Deletion case03. }
  \label{fig_IpCHashT_deletion_case03}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_21.pdf}
  \caption{ Deletion case04. }
  \label{fig_IpCHashT_deletion_case04}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_22.pdf}
  \caption{ Deletion case05. }
  \label{fig_IpCHashT_deletion_case05}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.73]{./figs_algo/algorism_crop_23.pdf}
  \caption{ Deletion case06. }
  \label{fig_IpCHashT_deletion_case06}
\end{figure}

%---

