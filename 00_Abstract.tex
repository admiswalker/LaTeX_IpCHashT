\thispagestyle{empty} % ページ番号を表示しない．

% レイアウトを他の章のはじめのページと揃える．
　\\
\\
\\
\\
\noindent{\Huge \sf 要旨}\\
\\
\\
\\

ハッシュ法は，
入力されたキーと対応する値に定数時間でアクセスする探査アルゴリズムである
\footnote{
特定のキーと対応する値を返却することから，
この機構を「ある単語」と「その説明」に見立てて
「辞書」という名称で実装するプログラミング言語も多い．
}．
これは，コンピュータにおける配列アクセスが定数時間であることを利用している
\footnote{
単純には，アドレス線に読み込み先のメモリ番地を指定すると，対応するメモリ番地からデータ線に値が出力されるように，コンピュータが構成されている．
それぞれのメモリ番地はアドレス線が自身の番地を示していないか常に電圧を確認しており，
電圧が自分の番地を示すと，スイッチがオンとなり，データ線に値を出力する．
このため，定数時間で値が出力される．
}．
もし，キーが連続した整数値であるなら，
キーが配列インデックスと等しいときに，キーと対応する値を配列に格納しておく．
すると，キーに紐付いた値は，配列インデックスにキーを代入することで取得できる
\footnote{
整数値が 0 始まりでない場合は，当然，配列インデックスからオフセットを差し引く．
}．
これを拡張して，ハッシュ法では，キーがどのような値でも，配列アクセスを利用した高速な応答性能を実現する．
まず，キーをインデックスとして配列にアクセスするには，キーを配列サイズ未満の一意な正の整数に変換する必要がある．
そこで，ハッシュ関数によりキーを正の整数に変換する．
ハッシュ関数は，一定の法則で値をシャッフルする関数で，同じ入力には同じ出力を得る．
出力のハッシュ値は，一見乱数のような値であり，剰余演算などにより，ハッシュ値を配列サイズ未満に丸める．
以上により，任意のキーに対応する値を，ハッシュ関数の定める配列インデックスに登録しておくことで，定数時間によるアクセスができる．
このとき，配列はキー (key) と値 (value) の対応を表す表 (table) であるため，ハッシュテーブルと表現する．
また，key と value の対応を key-value ペアと表現する．
ハッシュ法が定数時間による探査を実現する戦略は，以上である．

ところが，この手法をそのまま実装すると，
配列サイズ未満に丸めたハッシュ値が，高い確率で衝突するため
\footnote{
同じ配列要素に 2 つ以上の値が割り当てられることを，secondary clustering と呼ぶ．
ハッシュ関数が低品質な場合は，secondary clustering が特に深刻となる．
}，
実用に耐えない．
1 つの配列要素に 2 つの値は格納できないため，衝突を解決するアルゴリズムが必要となる．
本研究で示すアルゴリズムも，数多ある衝突解決アルゴリズムの 1 つである．
一般に，
衝突を解決する処理はハッシュ法の効率を落とすため，
衝突が発生しないよう，
丸めたハッシュ値は配列全体に均一に分布することが理想的である．
しかし現実には，丸めたハッシュ値が均一に分布することはなく，配列の利用率が高くなる程，簡単に衝突する．
配列の利用率は load factor と呼ばれ
\footnote{
日本語では座席利用率と呼ぶ．
}，
load factor が高い場合には，
配列に格納した key-value ペアをより広い配列に移すことで衝突を解決する．この操作をリハッシュと呼ぶ
\footnote{
リハッシュする際は，リハッシュ時間を定数時間に収めるため，通常は倍サイズの配列に移す．
ただし，ここでの定数時間とは，
遷移先が倍サイズ以上の配列サイズであれば，
繰り返しリハッシュした場合の計算量を１要素ごとに分割したコストが O(n) となり，
要素数に比例した計算量と見なせることを意味する．
}．
しかし，メモリ効率と実行効率を考えると，衝突の度にリハッシュする訳には行かない．
そのため，load factor が低い場合には，リハッシュ以外の方法で衝突を解決する．

リハッシュ以外の衝突解決策は，主に 2 種類に大別される．
1 つは chaining に代表される open hashing\footnote{別名：closed addressing．} である．
衝突が発生した際，新しく 1 要素分のメモリ領域を確保し，片方向リスト\footnote{英名：singly linked list．} により現在の要素に追加する．
この手法は，
要素の削除と追加を繰り返す場合でも安定して動作する一方，
要素をポインタにより接続するため，アドレスが不連続となり CPU キャッシュが効き難い．
もう 1 つは linear probing や quadratic probing に代表される closed hashing\footnote{別名：open addressing．} である．
衝突が発生した際，それぞれの探査規則に従い，隣接する空き要素に値を格納する．
Linear probing は，隣接する $1, 2, 3, ... k$ 番目の要素を線形走査し，空き要素に値を格納する．
配列が隙間なく埋まった場合は，
境界が分からず探査時間は大きく増加する．これを primary clustering と呼ぶ．
% \footnote{Primary clustering と呼ぶ}．
% \href{https://en.wikipedia.org/wiki/Primary_clustering}{Primary clustering - wikipedia - 2019.06.22}}
% https://books.google.co.jp/books?id=HJ9gds_zhVEC&pg=PA186&redir_esc=y#v=onepage&q&f=false, ISBN 9780763725624 - Google Books
Quadratic probing は，隣接する $1^2, 2^2, 3^2, ... k^2$ 番目の要素を探査する．
飛び値を取るため，primary clustering し難い．
いずれの probing も，空の要素が探査終了条件の 1 つ\footnote{最悪計算量を保証するため，探査回数を制限することもある．} であるため，
要素を削除すると「要素が削除された」のか「要素が存在しない」のか判断できない．
このため，要素削除時は，削除フラグを付与する．
これらの probing 手法は，
要素の削除と追加を繰り返す場合において，性能低下とそれに伴うリハッシュを必要とする一方，
隣接する配列や，飛び値の場合にも比較的近いアドレスに要素を格納するため，
CPU キャッシュが効き易い利点がある．

Closed hashing には，
これにまでに挿入したキーのハッシュ先とは衝突していないにも関わらず，
primary clustering により，
ハッシュ先が別の隣接要素の退避先として使用されていることがある．
この場合，従来手法では，単に衝突として扱い probing により空き領域へ挿入する．
これは挿入時間を低下させる反面，探査には追加の時間を必要とする．

本研究では，ハッシュ先自体に衝突のない場合は，
挿入済みの要素を入れ替え，
ハッシュ先が一意に定まるキーを優先的に挿入するアルゴリズムを提案する．
これには，
挿入済みの要素が，何処に挿入されるべきであったかを把握する必要がある．
このため，ハッシュテーブルには双方向リスト\footnote{英名：doubly linked list．} 構造を用いる．
通常のリスト構造は，ポインタを用いるためアドレスが不連続となり CPU キャッシュが効き難くなる．
そのため，双方向リスト構造は，
要素の接続をポインタではなく uint8 または uint16 を用いた相対位置による in-place 実装により実現した．

Key と value に uint64 を用いた結果として，
uint8 を双方向リスト構造に用いた場合は，
テーブルサイズ $10^2〜10^{7}$ において，従来手法よりも高速な successful search または unsuccessful search を実現した．
uint16 を双方向リスト構造に用いた場合は，closed hashing として従来手法より 25 \%\footnote{従来の 75 \% のメモリ使用率．} 程度高いメモリ効率を実現した．
また，サイズが $10^7〜10^{8.3}$ の巨大なテーブルにおいて，従来手法より高速な unsuccessful search を実現した．

