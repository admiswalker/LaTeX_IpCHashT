\thispagestyle{empty} % ページ番号を表示しない．

% レイアウトを他の章のはじめのページと揃える．
　\\
\\
\\
\\
\noindent{\Huge \sf 要旨}\\
\\
\\
\\

ハッシュ法は，
入力されたキーに対応する値に定数時間でアクセスする探査アルゴリズムである．
これは，コンピュータにおける配列アクセスが定数時間であることを利用している
\footnote{
単純には，アドレス線に読み込み先のメモリ番地を指定すると，対応するメモリ番地から，データ線に値が出力されるように，コンピュータが構成されている．
それぞれのメモリ番地は，アドレス線が自身の番地を示していないか，常に電圧を確認しており，
電圧が自分の番地を示すと，スイッチがオンになり，データ線に値を出力する．
このため，定数時間で値が出力される．
}．
特定のキーに対応する値を返却することから，
この対応関係を「ある単語」と「その説明」に見立てて
「辞書」という名称で実装するプログラミング言語も多い．
もし，キーが連続した整数値であるなら，
キーが配列インデックスと等しいときに，キーと対応する値を配列に格納しておく．
すると，キーに紐付いた値は，配列のインデックスとしてキーを代入することで取得できる
\footnote{
整数値が 0 始まりでない場合は，当然，配列インデックスからオフセットを差し引く．
}．
これを拡張して，ハッシュ法では，キーがどのような値でも，配列アクセスを利用した高速な応答性能を実現する．
まず，キーをインデックスとして配列にアクセスするには，キーを配列サイズ未満の一意な正の整数に変換する必要がある．
そこで，ハッシュ関数によりキーを正の整数に変換する．
ハッシュ関数は，一定の法則で値をシャッフルする関数で，同じ入力には同じ出力を得る．
出力のハッシュ値は，一見乱数のような値であり，剰余演算などにより，ハッシュ値を配列サイズ未満に丸める．
以上により，任意のキーに対応する値を，ハッシュ関数の定める配列インデックスに登録しておくことで，定数時間による参照ができる．
このとき，配列はキー (key) と値 (value) の対応を表す表 (table) であるため，ハッシュテーブルと表現する．
また，key と value の対応を key-value ペアと表現する．

ハッシュ法が定数時間による探査を実現ための戦略は，以上であるが，
実際には，ハッシュ値，特に配列サイズ未満に丸めたハッシュ値は，高い確率で衝突する
\footnote{
同じ配列要素に割り当てられることを，secondary clustering と呼ぶ．ハッシュ関数が低品質な場合は，secondary clustering が特に深刻となる．
}．
1 つの配列要素に 2 つの値は格納できないため，衝突を解決するアルゴリズムが必要となる．
本研究で示すアルゴリズムも，数多ある衝突解決アルゴリズムの 1 つである．
一般に，
衝突を解決する処理はハッシュ法の効率を落とすため，
丸めたハッシュ値は配列全体に均一に分布することが理想的である．
しかし，現実に均一分布することはなく，配列の利用率が高くなる程，簡単に衝突する．
配列の利用率は load factor と呼ばれ，日本語では座席利用率と呼ぶ．
Load factor が高い場合には，
配列に格納した key-value ペアをより広い配列に移すことで衝突を解決する．この操作をリハッシュと呼ぶ
\footnote{
リハッシュを行う際は，リハッシュ時間を定数時間に収めるため，通常は倍サイズの配列長に遷移させる．
ただし，ここでの定数時間とは，繰り返し遷移させた場合のコストを１要素ごとで分割したコストが，単に O(n) となることを意味する．
}．
しかし，メモリ効率と実行効率を考えると，衝突の度にリハッシュする訳には行かない．
そのため，load factor が低い場合には，リハッシュ以外の方法で衝突を解決する．

リハッシュ以外の衝突解決策は，主に 2 種類に大別される．
1 つ目は chaining に代表される open hashing\footnote{別名：closed addressing．} である．
衝突が発生した際，新しく 1 要素分のメモリ領域を確保し，片方向リスト\footnote{英名：singly linked list．} により現在の要素に追加する．
この手法は，
要素の削除と追加を繰り返す場合でも安定して動作する一方，
要素をポインタにより接続するため，アドレス空間が不連続となり CPU キャッシュが効き難い．
2 つ目は linear probing や quadratic probing に代表される closed hashing\footnote{別名：open addressing．} である．
衝突が発生した際，それぞれの探査規則に従い，隣接する空き要素に値を格納する．
Linear probing は，隣接する $1, 2, 3, ... k$ 番目の要素に線形探査し，空き要素に値を格納する．
配列が隙間なく埋まった場合は，
境界が分からず探査時間は大きく増加する．これを primary clustering と呼ぶ．
% \footnote{Primary clustering と呼ぶ}．
% \href{https://en.wikipedia.org/wiki/Primary_clustering}{Primary clustering - wikipedia - 2019.06.22}}
% https://books.google.co.jp/books?id=HJ9gds_zhVEC&pg=PA186&redir_esc=y#v=onepage&q&f=false, ISBN 9780763725624 - Google Books
Quadratic probing は，隣接する $1^2, 2^2, 3^2, ... k^2$ 番目の要素を探査する．
飛び値を取るため，primary clustering し難い．
いずれの probing も，空の要素が探査終了条件の一つ\footnote{最悪計算量を保証するため，ホップ数を制限することもある．} であるため，
要素を削除すると「要素が削除された」のか「要素が存在しない」のか判断できない．
このため，要素削除時は，削除フラグを付与する．
これらの probing 手法は，
要素の削除と追加を繰り返す場合において，性能低下とそれに伴うリハッシュを必要とするが，
要素を隣接する要素に格納するため，CPU キャッシュが効き易い利点がある．

%課題とする特性は次の通りである．

本研究では，
新しい closed hashing アルゴリズムを扱う．
本研究で対象とする closed hashing の課題は，
primary clustering に分類される，
これにまでに挿入したキーのハッシュ先とは衝突していないにも関わらず，
既に，別の隣接要素の退避先として使用されている場合である，
この場合，従来手法では，単に衝突として扱い probing により空き領域へ挿入する．
これは，挿入時間を低下させる反面，探査に追加の時間を必要とする．

本研究では，ハッシュ先自体に衝突のない場合は，
優先的に挿入されるように，挿入済みの要素を入れ替えるアルゴリズムを提案する．
これには，
挿入済みの要素が，何処に挿入されるべきであったかを把握する必要がある．
このため，ハッシュテーブルには双方向リスト\footnote{英名：doubly linked list．} 構造を用いる．
通常のリスト構造は，ポインタを用いるため，
アドレスの保持に 64 bits のメモリ空間を消費する\footnote{64 bits CPU の場合．}．
これは，key に uint64，value に uint64 を用いる場合，
少なくとも 2 倍のメモリを消費し，データもキャッシュに乗り難くなる．
そのため，双方向リスト構造は，
要素の接続をアドレスではなく uint8 または uint16 を用いた相対位置による in-place 実装により実現した．

key-value ペアにそれぞれ uint64 を用いた結果，
双方向リスト構造に uint8 を用いた場合は，
テーブルサイズ $10^2〜10^{7}$ において，従来手法よりも高速な successful search または unsuccessful search を実現した．
また，
uint16 を用いた場合は，Closed hashing として従来手法より 30 \%\footnote{従来の 75 \% のメモリ使用率．} 程度高いメモリ効率と，
サイズが $10^7〜10^{8.3}$ の巨大なテーブルにおいて，高い successful search または従来手法より高速な unsuccessful search を実現した．







