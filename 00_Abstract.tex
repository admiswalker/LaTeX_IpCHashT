\thispagestyle{empty} % ページ番号を表示しない．

% レイアウトを他の章のはじめのページと揃える．
　\\
\\
\\
\\
\noindent{\Huge \sf 要旨}\\
\\
\\
\\

ハッシュ法は，
入力された key に対応する value を O(1) の計算量で参照する探査アルゴリズムである．
コンピュータにおける配列アクセスが O(1) の計算量であることを利用している．
もし，key が連続した整数値であれば，配列に格納した value を，配列のインデックス参照できる．
これを拡張して，ハッシュ法では，key が連続した整数値でない場合においても，配列アクセスを利用した高速な応答性能を提供する．
まず，key を配列のインデックスとしてアクセスするには，key を配列サイズ未満の整数値に変換する必要がある．
そこで，key をハッシュ関数により整数値に変換する．
ハッシュ関数は，一定の法則で値をシャッフルする関数で，乱数のような値を返却するが，同じ key に対しては常に同じ値を返却する．
次に，剰余演算などにより，ハッシュ値を配列サイズ未満に丸める．
これにより，任意の key に対応する value を配列として参照できる．
このとき，配列は key と value の対応を表す表であるため，ハッシュテーブルと表現する．
また， key と値の対応を key-value ペアと表現する．

一般に，
ハッシュ値の剰余は配列全体に均一に分布することが望ましいが，
実際には配列の利用率を示す load factor \footnote{別名：座席利用率．} の増加に伴い簡単に衝突する．
%衝突確率を下げるには，より広い値空間に移せばよく，この操作をリハッシュと呼ぶ
%\footnote{リハッシュを行う際は，リハッシュ時間を定数時間に収めるため，通常は倍サイズの配列長に遷移させる．
%ただし，ここでの定数時間とは，繰り返し遷移させた場合のコストを１要素ごとで分割したコストが，単に O(n) となることを意味する．}
%．一般に，Chain 法．
剰余の衝突は，key-value ペアをより広い配列へ移すことで解決できる．この操作をリハッシュと呼ぶ．
しかし，メモリ効率と実行効率を考えると，衝突の度にリハッシュを行う訳には行かない．
そのため，リハッシュ以外の方法で衝突を解決する必要がある．

剰余衝突の解決策は，主に２種類に大別される．
1 つ目は，
Chaining に代表される Open hashing\footnote{別名：Closed addressing．} である．
衝突が発生した際，新しくメモリ領域を確保し，片方向リスト\footnote{別名：linked list または singly linked list，} により現在の要素に追加する．
この手法は，
要素の削除と追加を繰り返す場合でも安定して動作するが，要素をポインタにより接続するため，
アドレス空間が連続とならず CPU キャッシュが効き難い欠点がある．
2 つ目は，
Linear probing や Quadratic probing に代表される Closed hashing\footnote{別名：Open addressing．} である．
衝突が発生した際，それぞれの probing 規則に従い，隣接する空き要素に値を格納する．
Linear probing は，隣接する $1, 2, 3, ... k$ 番目の要素を線形探査する．
% 隣接する要素に値が格納されている場合は，高速に取り出せる．しかし，
配列が隙間なく埋まった場合は，
境界が分からず探査時間は大きく増加する．これを Primary clustering と呼ぶ．
% \footnote{Primary clustering と呼ぶ}．
% \href{https://en.wikipedia.org/wiki/Primary_clustering}{Primary clustering - wikipedia - 2019.06.22}}
% https://books.google.co.jp/books?id=HJ9gds_zhVEC&pg=PA186&redir_esc=y#v=onepage&q&f=false, ISBN 9780763725624 - Google Books
Quadratic probing は，隣接する $1^2, 2^2, 3^2, ... k^2$ 番目の要素を探査する．
飛び値を取るため，比較的 Primary clustering し難い．
いずれの probing も，空の要素が探査終了条件 \footnote{最悪計算量を保証するため，ホップ数を制限することもある．} の一つであるため，
要素を削除すると「要素が削除された」のか「要素が存在しない」のか判断できない．
このため，要素削除時は，削除フラグを付与する．
これらの手法は，
要素の削除と追加を繰り返す場合において，性能低下とそれに伴うリハッシュを必要とするが，
要素を隣接する要素に格納するため，CPU キャッシュが効き易い利点がある．

%% たぶん，ここはつぎの段落に統合される．
%課題とする特性は次の通りである．
%要素を挿入する際，
%Open hashing は，必ず剰余値が探査すべき片方向リストの先頭アドレスを示すのに対して，
%Closed hashing が示す剰余値のアドレスは probing すべき最初の要素の場合と，
%挿入先の配列が使用中のため，隣接する未使用の配列に移動された要素の場合がある．
%一方で，Closed hashing は Open hashing と比較してキャッシュミスを起こしにくい
%\footnote{キャッシュの有効性は，全ての要素を探査する必要のある unsuccessful lookup において，特に顕著となる．
%また，剰余の衝突の程度により変化する．}．
%また，load factor の観点において，
%Open hashing は，剰余がすべての配列番号に分布しない限り配列を使い切ることができないため，
%load factor を上げるには，剰余の衝突による lookup 速度の低下を許容する必要がある．
%これは，load factor と  lookup 速度がトレードオフの関係にあることを示す．
%Closed hashing においても，load factor が上がるほど，配列の隙間がなくなり lookup 速度が低下する．
%ただし，Quadratic probing においては特に，この速度低下は緩やかである．
%\footnote{たとえば，Google は，Knuth が 80 \% 程度でリハッシュするのがよいとしている{\bf \color{red}（要出典）}とした上で，
%速度を求めて google::dense\_hash\_map の load factor を 50 \% に制限している (dense\_hash\_map のコメントより)．}

まず，Closed hashing は，
対象となる key の剰余値自体はこれにまでに挿入した key の剰余値と衝突していないにも関わらず，
既に，別の隣接要素の避難先として使用されている場合がある，
この場合，従来手法では，単に衝突として扱い probing により空き領域へ挿入する．
これは，挿入時間を低下させる反面，lookup に追加の proobing が必要となる．

本研究では，剰余値自体に衝突のない場合は，
優先的に挿入されるように，挿入済みの要素を入れ替えるアルゴリズムを提案する．
これには，
挿入済みの要素が，何処に挿入されるべきであったかを把握する必要があるため，
双方向リスト構造を用いる．
通常のリスト構造は，ポインタを用いるため，
アドレスの保持に 64 bits のメモリ空間を消費する\footnote{64 bits CPU の場合．}．
これは，key に uint64，value に uint64 を用いる場合，
少なくとも 2 倍のメモリを消費するだけでなく，
データがキャッシュに乗り難くなることを意味する．
そのため，双方向リスト構造の実現には，
要素の接続をアドレスではなく uint8 を用いた相対位置により in-place 実装した．

結果，
挿入速度と引き換えに，
従来よりも高速な successful lookup と unsuccessful lookup を実現し，
高い load factor による高いメモリ効率と，
要素の削除と追加による性能低下の少ないハッシュテーブルのアルゴリズムを開発した．






