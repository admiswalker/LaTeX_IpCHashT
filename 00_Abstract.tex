\thispagestyle{empty} % ページ番号を表示しない．

% レイアウトを他の章のはじめのページと揃える．
　\\
\\
\\
\\
\noindent{\Huge \sf 要旨}\\
\\
\\
\\

ハッシュテーブルは，
ハッシュ化された入力キーを配列サイズで除算した際の余り (modulo) を配列のインデックスとして値を格納することで，
キーに対応する値を，定数時間で高速に取得するアルゴリズムである．
ハッシュテーブルは，キーと対応した値を保持する表であることから，配列のことをテーブルと表現する．
また，キーと値の対応を key-value ペアと表現する．

一般に，
ハッシュ値の剰余は配列全体に均一に分布することが望ましいが，
実際には配列の利用率を示す load factor \footnote{別名：座席利用率．} の増加に伴い衝突する．
%衝突確率を下げるには，より広い値空間に移せばよく，この操作をリハッシュと呼ぶ
%\footnote{リハッシュを行う際は，リハッシュ時間を定数時間に収めるため，通常は倍サイズの配列長に遷移させる．
%ただし，ここでの定数時間とは，繰り返し遷移させた場合のコストを１要素ごとで分割したコストが，単に O(n) となることを意味する．}
%．一般に，Chain 法．
剰余の衝突は，key-value ペアをより広い配列へ移すことで解決できる．
この操作をリハッシュと呼ぶ．
しかし，メモリ効率上，実用的な load factor を達成するためには，
リハッシュ以外の方法で衝突を解決する必要がある．

剰余衝突の解決策は，主に２種類に大別される．
１つ目は，
Chaining に代表される Open hashing\footnote{別名：Closed addressing．} である．
衝突が発生した際，新しくメモリ領域を確保し，片方向リスト\footnote{別名：linked list または singly linked list，} により現在の要素に追加する．
この手法は，
要素の削除と追加を繰り返す場合でも安定して動作するが，要素をポインタにより接続するため，
アドレス空間が連続とならず CPU キャッシュが効き難い欠点がある．
２つ目は，
Linear probing や Quadratic probing に代表される Closed hashing\footnote{別名：Open addressing．} である．
衝突が発生した際，それぞれの probing 規則に従い，隣接する空き要素に値を格納する．
Linear probing は，隣接する $1, 2, 3, ... k$ 番目の要素を線形探査する．
% 隣接する要素に値が格納されている場合は，高速に取り出せる．しかし，
配列が隙間なく埋まった場合は，
境界が分からず探査時間は大きく増加する．これを Primary clustering と呼ぶ．
% \footnote{Primary clustering と呼ぶ}．
% \href{https://en.wikipedia.org/wiki/Primary_clustering}{Primary clustering - wikipedia - 2019.06.22}}
% https://books.google.co.jp/books?id=HJ9gds_zhVEC&pg=PA186&redir_esc=y#v=onepage&q&f=false, ISBN 9780763725624 - Google Books
Quadratic probing は，隣接する $1^2, 2^2, 3^2, ... k^2$ 番目の要素を探査する．
飛び値を取るため，比較的 Primary clustering し難い．
いずれの probing も，空の要素が探査終了条件 \footnote{最悪計算量を保証するため，ホップ数を制限することもある．} の一つであるため，
要素を削除すると「要素が削除された」のか「要素が存在しない」のか判断できない．
このため，要素削除時は，削除フラグを付与する．
これらの手法は，
要素の削除と追加を繰り返す場合において，性能低下とそれに伴うリハッシュを必要とするが，
要素を隣接する要素に格納するため，CPU キャッシュが効き易い利点がある．

課題とする特性は次の通りである．
要素を挿入する際，
Open hashing は，１回目で探査すべき片方向リストの先頭アドレスを必ず取得するのに対して，
Closed hashing が，１回目に取得するアドレスは，probing すべき最初の要素である場合と，
挿入先の配列が使用中のため，隣接する未使用の配列に移動された要素の場合がある．
一方で，Closed hashing は Open hashing と比較してキャッシュミスを起こしにくい
\footnote{キャッシュの有効性は，全ての要素を探査する必要のある unsuccessful lookup において，特に顕著となる．
また，剰余の衝突の程度により変化する．}．
また，load factor の観点において，
Open hashing は，剰余がすべての配列番号に分布しない限り配列を使い切ることができないため，
load factor を上げるには，剰余の衝突による lookup 速度の低下を許容する必要がある．
これは，load factor と  lookup 速度がトレードオフの関係にあることを示す．
Closed hashing においても，load factor が上がるほど，配列の隙間がなくなり lookup 速度が低下する．
ただし，Quadratic probing においては特に，この速度低下は緩やかである．
\footnote{たとえば，Google は，Knuth が 80 \% 程度でリハッシュするのがよいとしている{\bf \color{red}（要出典）}とした上で，
速度を求めて google::dense\_hash\_map の load factor を 50 \% に制限している (dense\_hash\_map のコメントより)．}

本研究では，．






