\chapter{ベンチマーク}
\label{chap_Results}

\section{環境}

ベンチマークの実行環境を，
表\ref{table_env}に示す．

\begin{table}[hbtp]
  \label{table_env}
  \begin{center}
    \caption{実行環境}
    \begin{tabular}{cc} \hline
      Component & Type \rule[0pt]{0pt}{0pt} \\ \hline
      CPU & AMD Ryzen7 1700 (8Cores/16Threads) \rule[0pt]{0pt}{0pt} \\ 
      & Base Clock 3GHz / Max Boost Clock 3.7GHz \rule[0pt]{0pt}{0pt} \\
      & Total L1 Cache: 768KB / Total L2 Cache: 4MB / Total L3 Cache: 16MB \\
      Memory & DDR4-2666 32GB \rule[0pt]{0pt}{0pt} \\
      OS & Ubuntu 16.04 LTS \rule[0pt]{0pt}{0pt} \\
      Compiler & gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.11) \rule[0pt]{0pt}{0pt} \\ \hline
    \end{tabular}
  \end{center}
\end{table}


%\section{IpCHashT の測定条件}
\section{各ハッシュテーブルの測定条件}
各ハッシュテーブルの key と value に uint64 型を指定して測定する．
テーブルごとの設定を次に示す．
\leavevmode \newline

%
{\bf std::unordered\_map<uint64,uint64>}

C++ の標準ライブラリに収録されているハッシュテーブル．
\leavevmode \newline

%
{\bf sstd::CHashT<uint64,uint64>}

``Separate chaining with list head cells'' の実装の一つ．比較用のサンプル実装．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
全要素数がテーブルサイズを超える時に，リハッシュする．
\leavevmode \newline

%
{\bf sstd::IpCHashT<uint64,uint64> (as uint8 and maxLF50)}

{\rm bench.hpp} 内で {\rm iHashT\_u8h} の別名により定義される設定．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
uint8 により linked list を構成する．
Load factor の最大値が 50 \% に制限されている．
\leavevmode \newline

%
{\bf sstd::IpCHashT<uint64,uint64> (as uint8 and maxLF100)}

{\rm bench.hpp} 内で {\rm iHashT\_u8} の別名により定義される設定．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
uint8 により linked list を構成する．
Load factor に制限はなく，link 距離が uint8 の幅を超えるか，テーブルが全て埋まるまで要素を挿入する．
\leavevmode \newline

%
{\bf sstd::IpCHashT<uint64,uint64> (as uint16 and maxLF100)}

{\rm bench.hpp} 内で {\rm iHashT\_u16} の別名により定義される設定．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
uint16 により linked list を構成する．
Load factor に制限はなく，link 距離が uint16 の幅を超えるか，テーブルが全て埋まるまで要素を挿入する．
\leavevmode \newline



\section{結果}

{\bf Loadfactor}

{\bf メモリ使用量}

{\bf 挿入}

{\bf 探査}

{\bf 削除}

\begin{figure}[h]
  \includegraphics[scale=0.24]{./fig_bench/maxLoadFactor_med.pdf}
  \caption{
    Maximum load factor. Maximum load factor of std::IpHashT is limitted by its maximum length of shift\_T.
    Maximum load factor of google::dense\_hash\_map is artificially limited by 50 \%.
  }
  \label{fig_bench_LF}
\end{figure}

\begin{figure}[h]
  \hspace{-1mm}
  \includegraphics[scale=0.24]{./fig_bench/usedMemory.pdf}
  \caption{ Allocated memory size. }
  \label{fig_bench_memory}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.24]{./fig_bench/insert_et_preAlloc_med.pdf}
  \caption{ Total time of insertion using pre-allocated table. }
  \label{fig_bench_insert_preAlloc}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.24]{./fig_bench/insert_et_med.pdf}
  \caption{ Total time of insertion with rehashing table. }
  \label{fig_bench_insert_wRehash}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench/insert_med.pdf}
  \caption{ Insertion speed. }
  \label{fig_bench_insert}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench/find_successful_lookup_med.pdf}
  \caption{ Successful lookup speed. }
  \label{fig_bench_insert}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench/find_unsuccessful_lookup_med.pdf}
  \caption{ Unsuccessful lookup speed. }
  \label{fig_bench_insert}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench/erase_med.pdf}
  \caption{ Erasion speed. }
  \label{fig_bench_insert}
\end{figure}
















