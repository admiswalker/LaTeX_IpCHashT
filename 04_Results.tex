\chapter{ベンチマーク}
\label{chap_Results}

\section{環境}

ベンチマークの実行環境を，
表\ref{table_env}に示す．

\begin{table}[hbtp]
  \label{table_env}
  \begin{center}
    \caption{Execution environment}
    \begin{tabular}{cc} \hline
      Component & Type \rule[0pt]{0pt}{0pt} \\ \hline
      CPU & AMD Ryzen7 1700 (8Cores/16Threads) \rule[0pt]{0pt}{0pt} \\ 
      & Base Clock 3GHz / Max Boost Clock 3.7GHz \rule[0pt]{0pt}{0pt} \\
      & Total L1 Cache: 768KB / Total L2 Cache: 4MB / Total L3 Cache: 16MB \\
      Memory & DDR4-2666 32GB \rule[0pt]{0pt}{0pt} \\
      OS & Ubuntu 16.04 LTS \rule[0pt]{0pt}{0pt} \\
      Compiler & gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.11) \rule[0pt]{0pt}{0pt} \\ \hline
    \end{tabular}
  \end{center}
\end{table}


%\section{IpCHashT の測定条件}
\section{各ハッシュテーブルの概要と測定条件}
各ハッシュテーブルの key と value に uint64 型を指定して測定する．
テーブルごとの設定を次に示す．
\leavevmode \newline

%
{\bf std::unordered\_map<uint64,uint64>}
\samepage\newline\indent
C++ の標準ライブラリに収録されているハッシュテーブル．
\leavevmode \newline

%
{\bf sstd::CHashT<uint64,uint64>}
\samepage\newline\indent
``Separate chaining with list head cells''
\footnote{``Separate chaining with linked lists'' がテーブルにポインタしか持たず，
ポインタで接続した先から初めて key-value ペアを持つのに対して，
``Separate chaining with list head cells'' ではテーブルにも key-value ペアを内包する．} の実装の一つ．
アルゴリズム比較用のサンプル実装として，
最もシンプルなハッシュテーブルアルゴリズムの一つを選択した．
本実装では，
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
全要素数がテーブルサイズを超える場合に，リハッシュする．
\leavevmode \newline

%
{\bf sstd::IpCHashT<uint64,uint64> (as uint8 and maxLF50)}
\samepage\newline\indent
提案アルゴリズムの実装の一つ．
uint8 により linked list を構成する．
Load factor の最大値を 50 \% に制限している．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
{\rm bench.hpp} 内で {\rm iHashT\_u8h} の別名により定義されている．
\leavevmode \newline

%
{\bf sstd::IpCHashT<uint64,uint64> (as uint8 and maxLF100)}
\samepage\newline\indent
提案アルゴリズムの実装の一つ．
uint8 により linked list を構成する．
Load factor に制限はなく，link 距離が uint8 の幅を超えるか，テーブルが全て埋まるまで要素を挿入する．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
{\rm bench.hpp} 内で {\rm iHashT\_u8} の別名により定義されている．
\leavevmode \newline

%
{\bf sstd::IpCHashT<uint64,uint64> (as uint16 and maxLF100)}
\samepage\newline\indent
提案アルゴリズムの実装の一つ．
uint16 により linked list を構成する．
Load factor に制限はなく，link 距離が uint16 の幅を超えるか，テーブルが全て埋まるまで要素を挿入する．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
{\rm bench.hpp} 内で {\rm iHashT\_u16} の別名により定義されている．
\leavevmode \newline

%
{\bf google::dense\_hash\_map<uint64,uint64>}
\samepage\newline\indent
Quadratic probing の実装の一つ．
メモリ効率が高く，探査速度が速い一方，
key 値の一つを空マークに，削除を行う場合はもう一つを削除マークとして予約する必要がある．
予約された値は，key 値として使用できない．
予約には，set\_empty\_key() 関数と set\_deleted\_key() 関数を用いる．
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号とする．
\leavevmode \newline

%
{\bf ska::flat\_hash\_map<uint64,uint64,ska::power\_of\_two\_std\_hash<uint64>>}
\samepage\newline\indent
Robin Hood Hashing の実装の一つ．
ska::power\_of\_two\_std\_hash<uint64> オプションにより，
テーブルサイズを 2 のべき乗とし，ハッシュ値の下位ビットをテーブル番号としている．

\leavevmode \newline


\section{結果}
ここでは，sstd::IpCHashT の linked list 長に uint8 と uint16 を用いた設定，load factor の最大値を 50 \% に制限した設定に加えて，
要素探査時に Successful lookup を優先した設定と，Unsuccessful lookup を優先した設定についてベンチマークする．
\leavevmode \newline

%
{\bf Loadfactor}
\samepage\newline\indent
Load factor とテーブルサイズの関係を図\ref{fig_bench_LF}に示す．
\leavevmode \newline

%
{\bf メモリ使用量}
\samepage\newline\indent
メモリ使用量とテーブルサイズの関係を図\ref{fig_bench_memory}に示す．
\leavevmode \newline

%
{\bf 挿入}
\samepage\newline\indent
挿入速度とテーブルサイズの関係を図
\ref{fig_bench_insert_preAlloc}，\ref{fig_bench_insert_wRehash}，\ref{fig_bench_insert}に示す．
挿入処理において，Hard insertion では find() 関数を用いるが，Soft insertion では，find() 関数を用いない．
本ベンチマークでは，Soft insertion を用いる．
したがって，Successful lookup と Unuccessful lookup オプションによる違いはない．
\leavevmode \newline

%
{\bf 探査}
\samepage\newline\indent
探査速度とテーブルサイズの関係を図
\ref{fig_bench_find_s_sm}，\ref{fig_bench_find_us_sm}，
\ref{fig_bench_find_s_um}，\ref{fig_bench_find_us_um}に示す．
図\ref{fig_bench_find_s_sm}，\ref{fig_bench_find_us_sm}は Successful lookup を優先した設定，
図\ref{fig_bench_find_s_um}，\ref{fig_bench_find_us_um}は Unsuccessful lookup を優先した設定である．
\leavevmode \newline

%
{\bf 削除}
\samepage\newline\indent
削除速度とテーブルサイズの関係を図
\ref{fig_bench_erase_sm}，
\ref{fig_bench_erase_um}に示す．
図\ref{fig_bench_erase_sm}は Successful lookup を優先した設定，
図\ref{fig_bench_erase_um}は Unsuccessful lookup を優先した設定である．
\leavevmode \newline

%\newpage

% AMD Ryzen7 1700
% Total L2 Cache:  4 MB
% Total L3 Cache: 16 MB

% key: uint64, value: uint64 -> 16 Byte/element
% 4 [MB] / 16 [Byte/element]
% = 4*1024*1024 [Byte] / 16 [Byte/element]
% = (1/4) * 1024*1024 [element]
% = 256*1024 [element]
% = 262144 [element]
% = 2.6x10^5 [element]

% key: uint64, value: uint64 -> 16 Byte/element
% 16 [MB] / 16 [Byte/element]
% = 16*1024*1024 [Byte] / 16 [Byte/element]
% = 1024*1024 [element]
% = 1048576 [element]
% = 1.0x10^6 [element]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{figure}[]
\begin{figure}[b]
%  \vspace{-0mm}
  \includegraphics[scale=0.24]{./fig_bench/maxLoadFactor_med.pdf}
  \caption{
    Maximum load factor which is median value of 100 samples.
    Maximum load factor of std::IpHashT (as maxLF100) is limitted by its maximum length of shift\_T.
    Maximum load factor of std::IpHashT (as maxLF50), google::dense\_hash\_map and ska::flat\_hash\_map is artificially limited by 50 \%.
  }
  \label{fig_bench_LF}
\end{figure}

%%%

\begin{figure}[h]
%  \vspace{-5mm}
  \hspace{-1mm}
  \includegraphics[scale=0.24]{./fig_bench/usedMemory.pdf}
  \caption{
    Allocated memory size, which is one sample raw data.
    Peaks of memory size indicate rehash timmings.
    And the width of peaks is measurement interval.
    This means that the actual waveform is more sharp.
    std::unordered\_map seems to allocating memory each by insertion.
    sstd::IpCHashTs are moved the timming of rehashing back and forth by the influence of maximum load factor.
    ska::flat\_hash\_map while it is hard to see, is plotted on the same place of sstd::IpCHashT (as maxLF50).
    {\bf ATTENTION: The table size of this graph is 10 times smaller than the others.}
  }
  \label{fig_bench_memory}
%  \vspace{-10mm}
\end{figure}

%%%

\begin{figure}[h]
  \includegraphics[scale=0.24]{./fig_bench_sm/insert_et_preAlloc_med.pdf}
  \caption{
    Total time of insertion, which is a median value of 100 samples, using pre-allocated table.
    In this measurement, hash tables are initialized by $2.0\times10^8$ and inserted.
    sstd::IpCHash (as maxLF50) and ska::flat\_hash\_map are rehashing around $1.25\textasciitilde.375\times10^8$.
    And sstd::IpCHash (as uint8 and maxLF100) is rehashing around $1.375\textasciitilde2.0\times10^8$.
  }
  \label{fig_bench_insert_preAlloc}
\end{figure}

\begin{figure}[h]
  \includegraphics[scale=0.24]{./fig_bench_sm/insert_et_med.pdf}
  \caption{
    Total time of insertion, which is a median value of 100 samples, with rehashing table.
    Chaining type of hash tables like sstd::CHashT and sstd::IpCHashT are slow down its insertion speed as the load factor increase.
  }
  \label{fig_bench_insert_wRehash}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_sm/insert_med.pdf}
  \caption{
    Insertion speed, which is a median value of 100 samples.
    Rehash time is included in the valleys.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_insert}
\end{figure}

%%%

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_sm/find_successful_lookup_med.pdf}
  \caption{
    (Successful lookup major option). Successful lookup speed, which is a median value of 100 samples.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_find_s_sm}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_usm/find_successful_lookup_med.pdf}
  \caption{
    (Unsuccessful lookup major option). Successful lookup speed, which is a median value of 100 samples.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_find_s_um}
\end{figure}

%%%

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_sm/find_unsuccessful_lookup_med.pdf}
  \caption{
    (Successful lookup major option). Unsuccessful lookup speed, which is a median value of 100 samples.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_find_us_sm}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_usm/find_unsuccessful_lookup_med.pdf}
  \caption{
    (Unsuccessful lookup major option). Unsuccessful lookup speed, which is a median value of 100 samples.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_find_us_um}
\end{figure}

%%%

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_sm/erase_med.pdf}
  \caption{
    (Successful lookup major option). Erasion speed, which is a median value of 100 samples.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_erase_sm}
\end{figure}

\begin{figure}[h]
  \hspace{-3mm}
  \includegraphics[scale=0.24]{./fig_bench_usm/erase_med.pdf}
  \caption{
    (Unsuccessful lookup major option). Erasion speed, which is a median value of 100 samples.
    About $1.0\times10^5$ elements will consume totally 4 MB of L2 cache,
    and about $1.0\times10^6$ elements will consume totally 16 MB of L3 cache on AMD Ryzen7 1700.
  }
  \label{fig_bench_erase_um}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%















