\chapter{結論}
\label{chap_Conclusion}

%結論について記述する．

本投稿では，
doubly linked list 構造を内包する Closed hashing アルゴリズムとして，
In-place Chained Hash Table を提案した．
図\ref{fig_taocp_v3_fig44}に示すように，
Chaining 系のアルゴリズムは， Successful lookup に加え，
特に Unsuccessful lookup に対して高い性能を示すことが期待された．
\newline

まず，{\bf sstd::IpCHashT (as uint8 and maxLF50)} の Unsuccessful lookup major option について結論を述べる．

Successful lookup speed について，
図\ref{fig_bench_find_s_um}より，
テーブルサイズ $1.0\times10^2〜1.0\times10^7$ において，
L2 キャッシュを跨ぐ $1.0\times10^5$ 前後を除き，
殆どの区間で，1 番目ないし，2 番目の実行速度を示した．
ただし，$1.0\times10^7$ を超える非常に巨大なハッシュテーブについては，
google::dense\_hash\_map がよい性能を示した．

Unsuccessful lookup speed については，
図\ref{fig_bench_find_us_um}より，
テーブルサイズ $1.0\times10^2〜1.0\times10^7$ において，
L2 キャッシュを跨ぐ $1.0\times10^5$ 前後を除き，
殆どの区間で，1 番目ないし，2 番目の実行速度を示した．
ただし，$1.0\times10^7$ を超える非常に巨大なハッシュテーブについては，
メモリ効率の最も高い sstd::IpCHashT (as uint16 and maxLF100) が，
最もよい性能を示した．

挿入速度に関しては，
図\ref{fig_bench_insert}に示す通り，必ずしも最速ではないものの，
図\ref{fig_bench_insert_wRehash}より，通常の使用において，
累積の挿入速度や，リハッシュ時間は極端に遅い訳ではないことを確認した．

削除速度に関しては，
図\ref{fig_bench_erase_um} に示す通り，
2\textasciitilde 3 番目の速度を示した．
\newline

{\bf sstd::IpCHashT (as uint8 and maxLF50)} の Successful lookup major option について結論を述べる．

Successful lookup speed について，
図\ref{fig_bench_find_s_sm}より，
Unsuccessful lookup major option の場合と比較して，
テーブルサイズ $3.0\times10^5〜1.0\times10^7$ において，
性能の改善が見られる．
それ以外の区間においては，大きな性能改善は見られず，
$1.0\times10^7$ を超える非常に巨大なハッシュテーブについては，
同様に性能が悪化した．

Unsuccessful lookup speed については，
図\ref{fig_bench_find_us_sm}より，
Unsuccessful lookup major option の場合と比較して，
L2 キャッシュサイズ内の $1.0\times10^2〜1.0\times10^5$ において，
大きく性能を落とした．
また，$1.0\times10^5〜1.0\times10^7$ においては，
ska::flat\_hash\_map が最も高い性能を示した．
\newline

{\bf sstd::IpCHashT (as uint16 and maxLF100)} の Successful lookup major option について結論を述べる．

Successful lookup speed について，
図\ref{fig_bench_find_s_sm}より，
区間 $1.0\times10^5〜3.5\times10^7$ において，
google::dense\_hash\_map と同程度の性能を示した．
区間 $3.5\times10^7〜2.0\times10^8$ においては，
google::dense\_hash\_map には劣るものの，
2 番目の性能に収まった．

Unsuccessful lookup speed については，
図\ref{fig_bench_find_s_sm}より，
区間 $1.0\times10^5〜3.5\times10^7$ において，
google::dense\_hash\_map と同程度の性能を示した．
区間 $3.5\times10^7〜2.0\times10^8$ においては，
最も速い性能を示した．

これらは，
google::dense\_hash\_map の 75 \% のメモリ使用量であることを鑑みれば，
よい結果であるといえる．

ただし，
挿入速度に関しては，
図\ref{fig_bench_insert} が示す通り，
load factor が高い場合に，極端に速度が低下するため，
図\ref{fig_bench_insert_wRehash} のように，
リハッシュを伴う要素の挿入には，
google::dense\_hash\_map の 1.7 倍程度の時間が掛かる．
もちろん，図\ref{fig_bench_insert_preAlloc} のように，
事前にハッシュテーブルが初期化されており，
load factor の比較的小さな領域を使用する場合には，
この限りではない．

削除速度に関しては，
図\ref{fig_bench_erase_sm} に示す通り，
sstd::CHashT よりは速い，程度の速度を保っている．




\leavevmode \newline
\leavevmode \newline
\leavevmode \newline
\leavevmode \newline
\leavevmode \newline
\leavevmode \newline
\leavevmode \newline
\leavevmode \newline
TODO: このあたりの結果を，いい感じの表にまとめる．






