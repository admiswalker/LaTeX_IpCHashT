\chapter{結論}
\label{chap_Conclusion}

%結論について記述する．

本投稿では，
doubly linked list 構造を内包する Closed hashing アルゴリズムとして，
In-place Chained Hash Table を提案した．
図\ref{fig_taocp_v3_fig44}に示すように，
Chaining 系のアルゴリズムは， successful search に加え，
特に unsuccessful search に対して高い性能を示すことが期待された．
\newline

まず，{\bf sstd::IpCHashT (as uint8 and maxLF50)} の unsuccessful search major option について結論を述べる．

Successful search speed について，
図\ref{fig_bench_find_s_um}より，
テーブルサイズ $1.0\times10^2〜1.0\times10^7$ において，
L2 キャッシュを跨ぐ $1.0\times10^5$ 前後を除き，
殆どの区間で，1 番目ないし，2 番目の実行速度を示した．
ただし，$1.0\times10^7$ を超える非常に巨大なハッシュテーブについては，
google::dense\_hash\_map がよい性能を示した．

Unsuccessful search speed については，
図\ref{fig_bench_find_us_um}より，
テーブルサイズ $1.0\times10^2〜1.0\times10^7$ において，
L2 キャッシュを跨ぐ $1.0\times10^5$ 前後を除き，
殆どの区間で，1 番目ないし，2 番目の実行速度を示した．
ただし，$1.0\times10^7$ を超える非常に巨大なハッシュテーブについては，
メモリ効率の最も高い sstd::IpCHashT (as uint16 and maxLF100) が，
最もよい性能を示した．

挿入速度に関しては，
図\ref{fig_bench_insert}に示す通り，必ずしも最速ではないものの，
図\ref{fig_bench_insert_wRehash}より，通常の使用において，
累積の挿入速度や，リハッシュ時間は極端に遅い訳ではないことを確認した．

削除速度に関しては，
図\ref{fig_bench_erase_um} に示す通り，
2\textasciitilde 3 番目の速度を示した．
\newline

{\bf sstd::IpCHashT (as uint8 and maxLF50)} の successful search major option について結論を述べる．

Successful search speed について，
図\ref{fig_bench_find_s_sm}より，
unsuccessful search major option の場合と比較して，
テーブルサイズ $3.0\times10^5〜1.0\times10^7$ において，
性能の改善が見られる．
それ以外の区間においては，大きな性能改善は見られず，
$1.0\times10^7$ を超える非常に巨大なハッシュテーブについては，
同様に性能が悪化した．

Unsuccessful search speed については，
図\ref{fig_bench_find_us_sm}より，
unsuccessful search major option の場合と比較して，
L2 キャッシュサイズ内の $1.0\times10^2〜1.0\times10^5$ において，
大きく性能を落とした．
また，$1.0\times10^5〜1.0\times10^7$ においては，
ska::flat\_hash\_map が最も高い性能を示した．
\newline

{\bf sstd::IpCHashT (as uint16 and maxLF100)} の successful search major option について結論を述べる．

Successful search speed について，
図\ref{fig_bench_find_s_sm}より，
区間 $1.0\times10^5〜3.5\times10^7$ において，
google::dense\_hash\_map と同程度の性能を示した．
区間 $3.5\times10^7〜2.0\times10^8$ においては，
google::dense\_hash\_map には劣るものの，
2 番目の性能に収まった．

Unsuccessful search speed については，
図\ref{fig_bench_find_s_sm}より，
区間 $1.0\times10^5〜3.5\times10^7$ において，
google::dense\_hash\_map と同程度の性能を示した．
区間 $3.5\times10^7〜2.0\times10^8$ においては，
最も速い性能を示した．

これらは，
google::dense\_hash\_map の 75 \% のメモリ使用量であることを鑑みれば，
よい結果であるといえる．

ただし，
挿入速度に関しては，
図\ref{fig_bench_insert} が示す通り，
load factor が高い場合に，極端に速度が低下するため，
図\ref{fig_bench_insert_wRehash} のように，
リハッシュを伴う要素の挿入には，
google::dense\_hash\_map の 1.7 倍程度の時間が掛かる．
もちろん，図\ref{fig_bench_insert_preAlloc} のように，
事前にハッシュテーブルが初期化されており，
load factor の比較的小さな領域を使用する場合には，
この限りではない．

削除速度に関しては，
図\ref{fig_bench_erase_sm} に示す通り，
sstd::CHashT よりは速い，程度の速度を保っている．
\newline

% best, good, medium, bad, worst
\begin{table}%[hbtp]
  \begin{center}
%    \fontsize{9pt}{10pt}\selectfont
    \fontsize{8.7pt}{10pt}\selectfont
    \caption{各実装の比較．}
    \begin{tabular}{c|c|ccc|ccc|c|c} \hline
        Implementation of      & Insert                & \multicolumn{3}{c|}{\begin{tabular}{c}Successful search\end{tabular}}       & \multicolumn{3}{c|}{\begin{tabular}{c}Unsuccessful search\end{tabular}}      & Erase                   & Memory                \rule[0pt]{0pt}{15pt} \\
        hash table             &                       & $10^{2\textasciitilde5}$     & $10^{5\textasciitilde7}$      & $10^{7\textasciitilde8.3}$    & $10^{2\textasciitilde5}$     & $10^{5\textasciitilde7}$      & $10^{7\textasciitilde8.3}$     &                         & efficiency            \rule[0pt]{0pt}{15pt} \\ \hline
        IpCHashT (u8-LF50-S)   & \cellcolor{cGood}good & \cellcolor{cBest}best   & \cellcolor{cBest}best   & \cellcolor{cBad }bad    & \cellcolor{cMedi}medium & \cellcolor{cMedi}medium & \cellcolor{cMedi}medium  & \cellcolor{cMedi}medium & \cellcolor{cBad }bad  \rule[0pt]{0pt}{15pt} \\
        IpCHashT (u8-LF50-U)   & \cellcolor{cGood}good & \cellcolor{cBest}best   & \cellcolor{cMedi}medium & \cellcolor{cBad }bad    & \cellcolor{cBest}best   & \cellcolor{cBest}best   & \cellcolor{cMedi}medium  & \cellcolor{cMedi}medium & \cellcolor{cBad }bad  \rule[0pt]{0pt}{15pt} \\
        IpCHashT (u16-LF100-S) & \cellcolor{cBad }bad  & \cellcolor{cBad }bad    & \cellcolor{cGood}good   & \cellcolor{cGood}good   & \cellcolor{cBad }bad    & \cellcolor{cBad }bad    & \cellcolor{cGood}good    & \cellcolor{cBad }bad    & \cellcolor{cBest}best \rule[0pt]{0pt}{15pt} \\
        IpCHashT (u16-LF100-U) & \cellcolor{cBad }bad  & \cellcolor{cBad }bad    & \cellcolor{cBad }bad    & \cellcolor{cMedi}medium & \cellcolor{cGood}good   & \cellcolor{cGood}good   & \cellcolor{cBest}best    & \cellcolor{cBad }bad    & \cellcolor{cBest}best \rule[0pt]{0pt}{15pt} \\
        dense\_hash\_map       & \cellcolor{cGood}good & \cellcolor{cGood}good   & \cellcolor{cMedi}medium & \cellcolor{cBest}best   & \cellcolor{cBad }bad    & \cellcolor{cBad }bad    & \cellcolor{cMedi}medium  & \cellcolor{cBest}best   & \cellcolor{cGood}good \rule[0pt]{0pt}{15pt} \\
        flat\_hash\_map        & \cellcolor{cBest}best & \cellcolor{cMedi}medium & \cellcolor{cMedi}medium & \cellcolor{cBad }bad    & \cellcolor{cBad }bad    & \cellcolor{cGood}good   & \cellcolor{cMedi}medium  & \cellcolor{cMedi}medium & \cellcolor{cBad }bad  \rule[0pt]{0pt}{15pt} \\ \hline
    \end{tabular}
%    Note: \ \ u8: uint8,\ \ \ u16: uint16,\ \ \ SL Opt.: Successful search major option,\ \ \ USL Opt.: Unsuccessful search major option.
    Note: \ \ u8: uint8,\ \ \ u16: uint16,\ \ \ S: Successful search major option,\ \ \ U: Unsuccessful search major option.
    \label{table_hashT_cmp}
  \end{center}
\end{table}
% 2*10^8 = 10^x
% log10( 2*10^8 ) = log10( 10^x )
% log10( 2*10^8 ) = x
%               x = 8.301...

以上の結果は，表\ref{table_hashT_cmp} のようにまとめられる．
これらの結果から，少なくとも，AMD Ryzen7 1700 上では，key type と value type が uint64 のハッシュテーブルについて，次のことが言える．
{\bf sstd::IpCHashT (as uint8, maxLF50 and successful search major option)} は，successful search の区間 $10^2〜10^7$ で最も優れた結果を出す．
{\bf sstd::IpCHashT (as uint8, maxLF50 and unsuccessful search major option)} は，successful search の区間 $10^2〜10^7$ で優れた結果を，
successful search の区間 $10^2〜10^7$ で最も優れた結果を出す．全体によい結果を出す区間が長く，使い勝手が良い．
一方で，メモリ効率は高くなく，$10^7$ を超える巨大なハッシュテーブの場合には，大きく性能を落とす．
{\bf sstd::IpCHashT (as uint16, maxLF100 and successful search major option)} は，最も高いメモリ効率を示し，
successful search の区間 $10^5〜10^8.3$ において，安定した性能を示す．
{\bf sstd::IpCHashT (as uint16,maxLF100 and unsuccessful search major option)} は，最も高いメモリ効率を示し，
unsuccessful search の区間 $10^7〜10^8.3$ で最も優れた結果を出す．
{\bf google::dense\_hash\_map} は，successful search の区間 $10^2〜10^8.3$ の測定範囲ほぼ全域に渡り，よい性能を示す．
特に，巨大なテーブルの場合でも，速度低下が緩やかである．また，メモリ効率もよい．
一方で，Unuccessful search については，非常に遅い結果となった．
また，要素の空きや削除を示すキーを登録する必要があり，登録したキーはキーとして扱えなくなる．
{\bf flat\_hash\_map} は，insertion で最も優れた性能を示した．






